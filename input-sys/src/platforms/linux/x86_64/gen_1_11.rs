/* automatically generated by rust-bindgen */

pub type __int32_t = ::libc :: c_int ; pub type __uint32_t = ::libc :: c_uint ; pub type __uint64_t = ::libc :: c_ulong ; pub type va_list = __builtin_va_list ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct udev { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct udev_device { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct libinput { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct libinput_device { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct libinput_device_group { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct libinput_seat { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct libinput_tablet_tool { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct libinput_event { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct libinput_event_device_notify { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct libinput_event_keyboard { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct libinput_event_pointer { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct libinput_event_touch { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct libinput_event_tablet_tool { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct libinput_event_tablet_pad { _unused : [ u8 ; 0 ] } pub const libinput_log_priority_LIBINPUT_LOG_PRIORITY_DEBUG : libinput_log_priority = 10 ; pub const libinput_log_priority_LIBINPUT_LOG_PRIORITY_INFO : libinput_log_priority = 20 ; pub const libinput_log_priority_LIBINPUT_LOG_PRIORITY_ERROR : libinput_log_priority = 30 ; pub type libinput_log_priority = ::libc :: c_uint ; pub const libinput_device_capability_LIBINPUT_DEVICE_CAP_KEYBOARD : libinput_device_capability = 0 ; pub const libinput_device_capability_LIBINPUT_DEVICE_CAP_POINTER : libinput_device_capability = 1 ; pub const libinput_device_capability_LIBINPUT_DEVICE_CAP_TOUCH : libinput_device_capability = 2 ; pub const libinput_device_capability_LIBINPUT_DEVICE_CAP_TABLET_TOOL : libinput_device_capability = 3 ; pub const libinput_device_capability_LIBINPUT_DEVICE_CAP_TABLET_PAD : libinput_device_capability = 4 ; pub const libinput_device_capability_LIBINPUT_DEVICE_CAP_GESTURE : libinput_device_capability = 5 ; pub const libinput_device_capability_LIBINPUT_DEVICE_CAP_SWITCH : libinput_device_capability = 6 ; pub type libinput_device_capability = ::libc :: c_uint ; pub const libinput_key_state_LIBINPUT_KEY_STATE_RELEASED : libinput_key_state = 0 ; pub const libinput_key_state_LIBINPUT_KEY_STATE_PRESSED : libinput_key_state = 1 ; pub type libinput_key_state = ::libc :: c_uint ; pub const libinput_led_LIBINPUT_LED_NUM_LOCK : libinput_led = 1 ; pub const libinput_led_LIBINPUT_LED_CAPS_LOCK : libinput_led = 2 ; pub const libinput_led_LIBINPUT_LED_SCROLL_LOCK : libinput_led = 4 ; pub type libinput_led = ::libc :: c_uint ; pub const libinput_button_state_LIBINPUT_BUTTON_STATE_RELEASED : libinput_button_state = 0 ; pub const libinput_button_state_LIBINPUT_BUTTON_STATE_PRESSED : libinput_button_state = 1 ; pub type libinput_button_state = ::libc :: c_uint ; pub const libinput_pointer_axis_LIBINPUT_POINTER_AXIS_SCROLL_VERTICAL : libinput_pointer_axis = 0 ; pub const libinput_pointer_axis_LIBINPUT_POINTER_AXIS_SCROLL_HORIZONTAL : libinput_pointer_axis = 1 ; pub type libinput_pointer_axis = ::libc :: c_uint ; pub const libinput_pointer_axis_source_LIBINPUT_POINTER_AXIS_SOURCE_WHEEL : libinput_pointer_axis_source = 1 ; pub const libinput_pointer_axis_source_LIBINPUT_POINTER_AXIS_SOURCE_FINGER : libinput_pointer_axis_source = 2 ; pub const libinput_pointer_axis_source_LIBINPUT_POINTER_AXIS_SOURCE_CONTINUOUS : libinput_pointer_axis_source = 3 ; pub const libinput_pointer_axis_source_LIBINPUT_POINTER_AXIS_SOURCE_WHEEL_TILT : libinput_pointer_axis_source = 4 ; pub type libinput_pointer_axis_source = ::libc :: c_uint ; pub const libinput_tablet_pad_ring_axis_source_LIBINPUT_TABLET_PAD_RING_SOURCE_UNKNOWN : libinput_tablet_pad_ring_axis_source = 1 ; pub const libinput_tablet_pad_ring_axis_source_LIBINPUT_TABLET_PAD_RING_SOURCE_FINGER : libinput_tablet_pad_ring_axis_source = 2 ; pub type libinput_tablet_pad_ring_axis_source = ::libc :: c_uint ; pub const libinput_tablet_pad_strip_axis_source_LIBINPUT_TABLET_PAD_STRIP_SOURCE_UNKNOWN : libinput_tablet_pad_strip_axis_source = 1 ; pub const libinput_tablet_pad_strip_axis_source_LIBINPUT_TABLET_PAD_STRIP_SOURCE_FINGER : libinput_tablet_pad_strip_axis_source = 2 ; pub type libinput_tablet_pad_strip_axis_source = ::libc :: c_uint ; pub const libinput_tablet_tool_type_LIBINPUT_TABLET_TOOL_TYPE_PEN : libinput_tablet_tool_type = 1 ; pub const libinput_tablet_tool_type_LIBINPUT_TABLET_TOOL_TYPE_ERASER : libinput_tablet_tool_type = 2 ; pub const libinput_tablet_tool_type_LIBINPUT_TABLET_TOOL_TYPE_BRUSH : libinput_tablet_tool_type = 3 ; pub const libinput_tablet_tool_type_LIBINPUT_TABLET_TOOL_TYPE_PENCIL : libinput_tablet_tool_type = 4 ; pub const libinput_tablet_tool_type_LIBINPUT_TABLET_TOOL_TYPE_AIRBRUSH : libinput_tablet_tool_type = 5 ; pub const libinput_tablet_tool_type_LIBINPUT_TABLET_TOOL_TYPE_MOUSE : libinput_tablet_tool_type = 6 ; pub const libinput_tablet_tool_type_LIBINPUT_TABLET_TOOL_TYPE_LENS : libinput_tablet_tool_type = 7 ; pub type libinput_tablet_tool_type = ::libc :: c_uint ; pub const libinput_tablet_tool_proximity_state_LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_OUT : libinput_tablet_tool_proximity_state = 0 ; pub const libinput_tablet_tool_proximity_state_LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_IN : libinput_tablet_tool_proximity_state = 1 ; pub type libinput_tablet_tool_proximity_state = ::libc :: c_uint ; pub const libinput_tablet_tool_tip_state_LIBINPUT_TABLET_TOOL_TIP_UP : libinput_tablet_tool_tip_state = 0 ; pub const libinput_tablet_tool_tip_state_LIBINPUT_TABLET_TOOL_TIP_DOWN : libinput_tablet_tool_tip_state = 1 ; pub type libinput_tablet_tool_tip_state = ::libc :: c_uint ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct libinput_tablet_pad_mode_group { _unused : [ u8 ; 0 ] } extern "C" {
 
 /// @ingroup tablet_pad_modes
///
/// Most devices only provide a single mode group, however devices such as
/// the Wacom Cintiq 22HD provide two mode groups. If multiple mode groups
/// are available, a caller should use
/// libinput_tablet_pad_mode_group_has_button(),
/// libinput_tablet_pad_mode_group_has_ring() and
/// libinput_tablet_pad_mode_group_has_strip() to associate each button,
/// ring and strip with the correct mode group.
///
/// @return the number of mode groups available on this device 
 
 pub fn libinput_device_tablet_pad_get_num_mode_groups ( device : * mut libinput_device , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup tablet_pad_modes
///
/// The returned mode group is not refcounted and may become invalid after
/// the next call to libinput. Use libinput_tablet_pad_mode_group_ref() and
/// libinput_tablet_pad_mode_group_unref() to continue using the handle
/// outside of the immediate scope.
///
/// While at least one reference is kept by the caller, the returned mode
/// group will be identical for each subsequent call of this function with
/// the same index and that same struct is returned from
/// libinput_event_tablet_pad_get_mode_group(), provided the event was
/// generated by this mode group.
///
/// @param device A device with the @ref LIBINPUT_DEVICE_CAP_TABLET_PAD
/// capability
/// @param index A mode group index
/// @return the mode group with the given index or NULL if an invalid index
/// is given. 
 
 pub fn libinput_device_tablet_pad_get_mode_group ( device : * mut libinput_device , index : ::libc :: c_uint , ) -> * mut libinput_tablet_pad_mode_group ; 
} extern "C" {
 
 /// @ingroup tablet_pad_modes
///
/// The returned number is the same index as passed to
/// libinput_device_tablet_pad_get_mode_group(). For tablets with only one
/// mode this number is always 0.
///
/// @param group A previously obtained mode group
/// @return the numeric index this mode group represents, starting at 0 
 
 pub fn libinput_tablet_pad_mode_group_get_index ( group : * mut libinput_tablet_pad_mode_group , ) -> ::libc :: c_uint ; 
} extern "C" {
 
 /// @ingroup tablet_pad_modes
///
/// Query the mode group for the number of available modes. The number of
/// modes is usually decided by the number of physical LEDs available on the
/// device. Different mode groups may have a different number of modes. Use
/// libinput_tablet_pad_mode_group_get_mode() to get the currently active
/// mode.
///
/// libinput guarantees that at least one mode is available. A device without
/// mode switching capability has a single mode group and a single mode.
///
/// @param group A previously obtained mode group
/// @return the number of modes available in this mode group 
 
 pub fn libinput_tablet_pad_mode_group_get_num_modes ( group : * mut libinput_tablet_pad_mode_group , ) -> ::libc :: c_uint ; 
} extern "C" {
 
 /// @ingroup tablet_pad_modes
///
/// Return the current mode this mode group is in. Note that the returned
/// mode is the mode valid as of completing the last libinput_dispatch().
/// The returned mode may thus be different than the mode returned by
/// libinput_event_tablet_pad_get_mode().
///
/// For example, if the mode was toggled three times between the call to
/// libinput_dispatch(), this function returns the third mode but the events
/// in the event queue will return the modes 1, 2 and 3, respectively.
///
/// @param group A previously obtained mode group
/// @return the numeric index of the current mode in this group, starting at 0
///
/// @see libinput_event_tablet_pad_get_mode 
 
 pub fn libinput_tablet_pad_mode_group_get_mode ( group : * mut libinput_tablet_pad_mode_group , ) -> ::libc :: c_uint ; 
} extern "C" {
 
 /// @ingroup tablet_pad_modes
///
/// Devices without mode switching capabilities return true for every button.
///
/// @param group A previously obtained mode group
/// @param button A button index, starting at 0
/// @return true if the given button index is part of this mode group or
/// false otherwise 
 
 pub fn libinput_tablet_pad_mode_group_has_button ( group : * mut libinput_tablet_pad_mode_group , button : ::libc :: c_uint , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup tablet_pad_modes
///
/// Devices without mode switching capabilities return true for every ring.
///
/// @param group A previously obtained mode group
/// @param ring A ring index, starting at 0
/// @return true if the given ring index is part of this mode group or
/// false otherwise 
 
 pub fn libinput_tablet_pad_mode_group_has_ring ( group : * mut libinput_tablet_pad_mode_group , ring : ::libc :: c_uint , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup tablet_pad_modes
///
/// Devices without mode switching capabilities return true for every strip.
///
/// @param group A previously obtained mode group
/// @param strip A strip index, starting at 0
/// @return true if the given strip index is part of this mode group or
/// false otherwise 
 
 pub fn libinput_tablet_pad_mode_group_has_strip ( group : * mut libinput_tablet_pad_mode_group , strip : ::libc :: c_uint , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup tablet_pad_modes
///
/// The toggle button in a mode group is the button assigned to cycle to or
/// directly assign a new mode when pressed. Not all devices have a toggle
/// button and some devices may have more than one toggle button. For
/// example, the Wacom Cintiq 24HD has six toggle buttons in two groups, each
/// directly selecting one of the three modes per group.
///
/// Devices without mode switching capabilities return false for every button.
///
/// @param group A previously obtained mode group
/// @param button A button index, starting at 0
/// @retval non-zero if the button is a mode toggle button for this group, or
/// zero otherwise 
 
 pub fn libinput_tablet_pad_mode_group_button_is_toggle ( group : * mut libinput_tablet_pad_mode_group , button : ::libc :: c_uint , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup tablet_pad_modes
///
/// Increase the refcount of the mode group. A mode group will be
/// freed whenever the refcount reaches 0.
///
/// @param group A previously obtained mode group
/// @return The passed mode group 
 
 pub fn libinput_tablet_pad_mode_group_ref ( group : * mut libinput_tablet_pad_mode_group , ) -> * mut libinput_tablet_pad_mode_group ; 
} extern "C" {
 
 /// @ingroup tablet_pad_modes
///
/// Decrease the refcount of the mode group. A mode group will be
/// freed whenever the refcount reaches 0.
///
/// @param group A previously obtained mode group
/// @return NULL if the group was destroyed, otherwise the passed mode group 
 
 pub fn libinput_tablet_pad_mode_group_unref ( group : * mut libinput_tablet_pad_mode_group , ) -> * mut libinput_tablet_pad_mode_group ; 
} extern "C" {
 
 /// @ingroup tablet_pad_modes
///
/// Set caller-specific data associated with this mode group. libinput does
/// not manage, look at, or modify this data. The caller must ensure the
/// data is valid.
///
/// @param group A previously obtained mode group
/// @param user_data Caller-specific data pointer
/// @see libinput_tablet_pad_mode_group_get_user_data
/// 
 
 pub fn libinput_tablet_pad_mode_group_set_user_data ( group : * mut libinput_tablet_pad_mode_group , user_data : * mut ::libc :: c_void , ) ; 
} extern "C" {
 
 /// @ingroup tablet_pad_modes
///
/// Get the caller-specific data associated with this mode group, if any.
///
/// @param group A previously obtained mode group
/// @return Caller-specific data pointer or NULL if none was set
/// @see libinput_tablet_pad_mode_group_set_user_data 
 
 pub fn libinput_tablet_pad_mode_group_get_user_data ( group : * mut libinput_tablet_pad_mode_group , ) -> * mut ::libc :: c_void ; 
} pub const libinput_switch_state_LIBINPUT_SWITCH_STATE_OFF : libinput_switch_state = 0 ; pub const libinput_switch_state_LIBINPUT_SWITCH_STATE_ON : libinput_switch_state = 1 ; pub type libinput_switch_state = ::libc :: c_uint ; pub const libinput_switch_LIBINPUT_SWITCH_LID : libinput_switch = 1 ; pub const libinput_switch_LIBINPUT_SWITCH_TABLET_MODE : libinput_switch = 2 ; pub type libinput_switch = ::libc :: c_uint ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct libinput_event_switch { _unused : [ u8 ; 0 ] } pub const libinput_event_type_LIBINPUT_EVENT_NONE : libinput_event_type = 0 ; pub const libinput_event_type_LIBINPUT_EVENT_DEVICE_ADDED : libinput_event_type = 1 ; pub const libinput_event_type_LIBINPUT_EVENT_DEVICE_REMOVED : libinput_event_type = 2 ; pub const libinput_event_type_LIBINPUT_EVENT_KEYBOARD_KEY : libinput_event_type = 300 ; pub const libinput_event_type_LIBINPUT_EVENT_POINTER_MOTION : libinput_event_type = 400 ; pub const libinput_event_type_LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE : libinput_event_type = 401 ; pub const libinput_event_type_LIBINPUT_EVENT_POINTER_BUTTON : libinput_event_type = 402 ; pub const libinput_event_type_LIBINPUT_EVENT_POINTER_AXIS : libinput_event_type = 403 ; pub const libinput_event_type_LIBINPUT_EVENT_TOUCH_DOWN : libinput_event_type = 500 ; pub const libinput_event_type_LIBINPUT_EVENT_TOUCH_UP : libinput_event_type = 501 ; pub const libinput_event_type_LIBINPUT_EVENT_TOUCH_MOTION : libinput_event_type = 502 ; pub const libinput_event_type_LIBINPUT_EVENT_TOUCH_CANCEL : libinput_event_type = 503 ; pub const libinput_event_type_LIBINPUT_EVENT_TOUCH_FRAME : libinput_event_type = 504 ; pub const libinput_event_type_LIBINPUT_EVENT_TABLET_TOOL_AXIS : libinput_event_type = 600 ; pub const libinput_event_type_LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY : libinput_event_type = 601 ; pub const libinput_event_type_LIBINPUT_EVENT_TABLET_TOOL_TIP : libinput_event_type = 602 ; pub const libinput_event_type_LIBINPUT_EVENT_TABLET_TOOL_BUTTON : libinput_event_type = 603 ; pub const libinput_event_type_LIBINPUT_EVENT_TABLET_PAD_BUTTON : libinput_event_type = 700 ; pub const libinput_event_type_LIBINPUT_EVENT_TABLET_PAD_RING : libinput_event_type = 701 ; pub const libinput_event_type_LIBINPUT_EVENT_TABLET_PAD_STRIP : libinput_event_type = 702 ; pub const libinput_event_type_LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN : libinput_event_type = 800 ; pub const libinput_event_type_LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE : libinput_event_type = 801 ; pub const libinput_event_type_LIBINPUT_EVENT_GESTURE_SWIPE_END : libinput_event_type = 802 ; pub const libinput_event_type_LIBINPUT_EVENT_GESTURE_PINCH_BEGIN : libinput_event_type = 803 ; pub const libinput_event_type_LIBINPUT_EVENT_GESTURE_PINCH_UPDATE : libinput_event_type = 804 ; pub const libinput_event_type_LIBINPUT_EVENT_GESTURE_PINCH_END : libinput_event_type = 805 ; pub const libinput_event_type_LIBINPUT_EVENT_SWITCH_TOGGLE : libinput_event_type = 900 ; pub type libinput_event_type = ::libc :: c_uint ; extern "C" {
 
 /// @ingroup event
///
/// Destroy the event, freeing all associated resources. Resources obtained
/// from this event must be considered invalid after this call.
///
/// @warning Unlike other structs events are considered transient and
/// <b>not</b> refcounted. Calling libinput_event_destroy() <b>will</b>
/// destroy the event.
///
/// @param event An event retrieved by libinput_get_event(). 
 
 pub fn libinput_event_destroy ( event : * mut libinput_event , ) ; 
} extern "C" {
 
 /// @ingroup event
///
/// Get the type of the event.
///
/// @param event An event retrieved by libinput_get_event(). 
 
 pub fn libinput_event_get_type ( event : * mut libinput_event , ) -> libinput_event_type ; 
} extern "C" {
 
 /// @ingroup event
///
/// Get the libinput context from the event.
///
/// @param event The libinput event
/// @return The libinput context for this event. 
 
 pub fn libinput_event_get_context ( event : * mut libinput_event , ) -> * mut libinput ; 
} extern "C" {
 
 /// @ingroup event
///
/// Return the device associated with this event. For device added/removed
/// events this is the device added or removed. For all other device events,
/// this is the device that generated the event.
///
/// This device is not refcounted and its lifetime is that of the event. Use
/// libinput_device_ref() before using the device outside of this scope.
///
/// @return The device associated with this event 
 
 pub fn libinput_event_get_device ( event : * mut libinput_event , ) -> * mut libinput_device ; 
} extern "C" {
 
 /// @ingroup event
///
/// Return the pointer event that is this input event. If the event type does
/// not match the pointer event types, this function returns NULL.
///
/// The inverse of this function is libinput_event_pointer_get_base_event().
///
/// @return A pointer event, or NULL for other events 
 
 pub fn libinput_event_get_pointer_event ( event : * mut libinput_event , ) -> * mut libinput_event_pointer ; 
} extern "C" {
 
 /// @ingroup event
///
/// Return the keyboard event that is this input event. If the event type does
/// not match the keyboard event types, this function returns NULL.
///
/// The inverse of this function is libinput_event_keyboard_get_base_event().
///
/// @return A keyboard event, or NULL for other events 
 
 pub fn libinput_event_get_keyboard_event ( event : * mut libinput_event , ) -> * mut libinput_event_keyboard ; 
} extern "C" {
 
 /// @ingroup event
///
/// Return the touch event that is this input event. If the event type does
/// not match the touch event types, this function returns NULL.
///
/// The inverse of this function is libinput_event_touch_get_base_event().
///
/// @return A touch event, or NULL for other events 
 
 pub fn libinput_event_get_touch_event ( event : * mut libinput_event , ) -> * mut libinput_event_touch ; 
} # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct libinput_event_gesture { _unused : [ u8 ; 0 ] } extern "C" {
 
 /// @ingroup event
///
/// Return the gesture event that is this input event. If the event type does
/// not match the gesture event types, this function returns NULL.
///
/// The inverse of this function is libinput_event_gesture_get_base_event().
///
/// @return A gesture event, or NULL for other events 
 
 pub fn libinput_event_get_gesture_event ( event : * mut libinput_event , ) -> * mut libinput_event_gesture ; 
} extern "C" {
 
 /// @ingroup event
///
/// Return the tablet tool event that is this input event. If the event type
/// does not match the tablet tool event types, this function returns NULL.
///
/// The inverse of this function is libinput_event_tablet_tool_get_base_event().
///
/// @return A tablet tool event, or NULL for other events 
 
 pub fn libinput_event_get_tablet_tool_event ( event : * mut libinput_event , ) -> * mut libinput_event_tablet_tool ; 
} extern "C" {
 
 /// @ingroup event
///
/// Return the tablet pad event that is this input event. If the event type does not
/// match the tablet pad event types, this function returns NULL.
///
/// The inverse of this function is libinput_event_tablet_pad_get_base_event().
///
/// @return A tablet pad event, or NULL for other events 
 
 pub fn libinput_event_get_tablet_pad_event ( event : * mut libinput_event , ) -> * mut libinput_event_tablet_pad ; 
} extern "C" {
 
 /// @ingroup event
///
/// Return the switch event that is this input event. If the event type does
/// not match the switch event types, this function returns NULL.
///
/// The inverse of this function is libinput_event_switch_get_base_event().
///
/// @return A switch event, or NULL for other events 
 
 pub fn libinput_event_get_switch_event ( event : * mut libinput_event , ) -> * mut libinput_event_switch ; 
} extern "C" {
 
 /// @ingroup event
///
/// Return the device event that is this input event. If the event type does
/// not match the device event types, this function returns NULL.
///
/// The inverse of this function is
/// libinput_event_device_notify_get_base_event().
///
/// @return A device event, or NULL for other events 
 
 pub fn libinput_event_get_device_notify_event ( event : * mut libinput_event , ) -> * mut libinput_event_device_notify ; 
} extern "C" {
 
 /// @ingroup event
///
/// @return The generic libinput_event of this event 
 
 pub fn libinput_event_device_notify_get_base_event ( event : * mut libinput_event_device_notify , ) -> * mut libinput_event ; 
} extern "C" {
 
 /// @ingroup event_keyboard
///
/// @note Timestamps may not always increase. See @ref event_timestamps for
/// details.
///
/// @return The event time for this event 
 
 pub fn libinput_event_keyboard_get_time ( event : * mut libinput_event_keyboard , ) -> u32 ; 
} extern "C" {
 
 /// @ingroup event_keyboard
///
/// @note Timestamps may not always increase. See @ref event_timestamps for
/// details.
///
/// @return The event time for this event in microseconds 
 
 pub fn libinput_event_keyboard_get_time_usec ( event : * mut libinput_event_keyboard , ) -> u64 ; 
} extern "C" {
 
 /// @ingroup event_keyboard
///
/// @return The keycode that triggered this key event 
 
 pub fn libinput_event_keyboard_get_key ( event : * mut libinput_event_keyboard , ) -> u32 ; 
} extern "C" {
 
 /// @ingroup event_keyboard
///
/// @return The state change of the key 
 
 pub fn libinput_event_keyboard_get_key_state ( event : * mut libinput_event_keyboard , ) -> libinput_key_state ; 
} extern "C" {
 
 /// @ingroup event_keyboard
///
/// @return The generic libinput_event of this event 
 
 pub fn libinput_event_keyboard_get_base_event ( event : * mut libinput_event_keyboard , ) -> * mut libinput_event ; 
} extern "C" {
 
 /// @ingroup event_keyboard
///
/// For the key of a @ref LIBINPUT_EVENT_KEYBOARD_KEY event, return the total number
/// of keys pressed on all devices on the associated seat after the event was
/// triggered.
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_KEYBOARD_KEY. For other events, this function returns 0.
///
/// @return The seat wide pressed key count for the key of this event 
 
 pub fn libinput_event_keyboard_get_seat_key_count ( event : * mut libinput_event_keyboard , ) -> u32 ; 
} extern "C" {
 
 /// @ingroup event_pointer
///
/// @note Timestamps may not always increase. See @ref event_timestamps for
/// details.
///
/// @return The event time for this event 
 
 pub fn libinput_event_pointer_get_time ( event : * mut libinput_event_pointer , ) -> u32 ; 
} extern "C" {
 
 /// @ingroup event_pointer
///
/// @note Timestamps may not always increase. See @ref event_timestamps for
/// details.
///
/// @return The event time for this event in microseconds 
 
 pub fn libinput_event_pointer_get_time_usec ( event : * mut libinput_event_pointer , ) -> u64 ; 
} extern "C" {
 
 /// @ingroup event_pointer
///
/// Return the delta between the last event and the current event. For pointer
/// events that are not of type @ref LIBINPUT_EVENT_POINTER_MOTION, this
/// function returns 0.
///
/// If a device employs pointer acceleration, the delta returned by this
/// function is the accelerated delta.
///
/// Relative motion deltas are to be interpreted as pixel movement of a
/// standardized mouse. See @ref motion_normalization for more details.
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_POINTER_MOTION.
///
/// @return The relative x movement since the last event 
 
 pub fn libinput_event_pointer_get_dx ( event : * mut libinput_event_pointer , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_pointer
///
/// Return the delta between the last event and the current event. For pointer
/// events that are not of type @ref LIBINPUT_EVENT_POINTER_MOTION, this
/// function returns 0.
///
/// If a device employs pointer acceleration, the delta returned by this
/// function is the accelerated delta.
///
/// Relative motion deltas are to be interpreted as pixel movement of a
/// standardized mouse. See @ref motion_normalization for more details.
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_POINTER_MOTION.
///
/// @return The relative y movement since the last event 
 
 pub fn libinput_event_pointer_get_dy ( event : * mut libinput_event_pointer , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_pointer
///
/// Return the relative delta of the unaccelerated motion vector of the
/// current event. For pointer events that are not of type @ref
/// LIBINPUT_EVENT_POINTER_MOTION, this function returns 0.
///
/// Relative unaccelerated motion deltas are raw device coordinates.
/// Note that these coordinates are subject to the device's native
/// resolution. Touchpad coordinates represent raw device coordinates in the
/// X resolution of the touchpad. See @ref motion_normalization for more
/// details.
///
/// Any rotation applied to the device also applies to unaccelerated motion
/// (see libinput_device_config_rotation_set_angle()).
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_POINTER_MOTION.
///
/// @return The unaccelerated relative x movement since the last event 
 
 pub fn libinput_event_pointer_get_dx_unaccelerated ( event : * mut libinput_event_pointer , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_pointer
///
/// Return the relative delta of the unaccelerated motion vector of the
/// current event. For pointer events that are not of type @ref
/// LIBINPUT_EVENT_POINTER_MOTION, this function returns 0.
///
/// Relative unaccelerated motion deltas are raw device coordinates.
/// Note that these coordinates are subject to the device's native
/// resolution. Touchpad coordinates represent raw device coordinates in the
/// X resolution of the touchpad. See @ref motion_normalization for more
/// details.
///
/// Any rotation applied to the device also applies to unaccelerated motion
/// (see libinput_device_config_rotation_set_angle()).
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_POINTER_MOTION.
///
/// @return The unaccelerated relative y movement since the last event 
 
 pub fn libinput_event_pointer_get_dy_unaccelerated ( event : * mut libinput_event_pointer , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_pointer
///
/// Return the current absolute x coordinate of the pointer event, in mm from
/// the top left corner of the device. To get the corresponding output screen
/// coordinate, use libinput_event_pointer_get_absolute_x_transformed().
///
/// For pointer events that are not of type
/// @ref LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE, this function returns 0.
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE.
///
/// @return The current absolute x coordinate 
 
 pub fn libinput_event_pointer_get_absolute_x ( event : * mut libinput_event_pointer , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_pointer
///
/// Return the current absolute y coordinate of the pointer event, in mm from
/// the top left corner of the device. To get the corresponding output screen
/// coordinate, use libinput_event_pointer_get_absolute_y_transformed().
///
/// For pointer events that are not of type
/// @ref LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE, this function returns 0.
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE.
///
/// @return The current absolute y coordinate 
 
 pub fn libinput_event_pointer_get_absolute_y ( event : * mut libinput_event_pointer , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_pointer
///
/// Return the current absolute x coordinate of the pointer event, transformed to
/// screen coordinates.
///
/// For pointer events that are not of type
/// @ref LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE, the return value of this
/// function is undefined.
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE.
///
/// @param event The libinput pointer event
/// @param width The current output screen width
/// @return The current absolute x coordinate transformed to a screen coordinate 
 
 pub fn libinput_event_pointer_get_absolute_x_transformed ( event : * mut libinput_event_pointer , width : u32 , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_pointer
///
/// Return the current absolute y coordinate of the pointer event, transformed to
/// screen coordinates.
///
/// For pointer events that are not of type
/// @ref LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE, the return value of this function is
/// undefined.
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE.
///
/// @param event The libinput pointer event
/// @param height The current output screen height
/// @return The current absolute y coordinate transformed to a screen coordinate 
 
 pub fn libinput_event_pointer_get_absolute_y_transformed ( event : * mut libinput_event_pointer , height : u32 , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_pointer
///
/// Return the button that triggered this event.
/// For pointer events that are not of type @ref
/// LIBINPUT_EVENT_POINTER_BUTTON, this function returns 0.
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_POINTER_BUTTON.
///
/// @return The button triggering this event 
 
 pub fn libinput_event_pointer_get_button ( event : * mut libinput_event_pointer , ) -> u32 ; 
} extern "C" {
 
 /// @ingroup event_pointer
///
/// Return the button state that triggered this event.
/// For pointer events that are not of type @ref
/// LIBINPUT_EVENT_POINTER_BUTTON, this function returns 0.
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_POINTER_BUTTON.
///
/// @return The button state triggering this event 
 
 pub fn libinput_event_pointer_get_button_state ( event : * mut libinput_event_pointer , ) -> libinput_button_state ; 
} extern "C" {
 
 /// @ingroup event_pointer
///
/// For the button of a @ref LIBINPUT_EVENT_POINTER_BUTTON event, return the
/// total number of buttons pressed on all devices on the associated seat
/// after the event was triggered.
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_POINTER_BUTTON. For other events, this function
/// returns 0.
///
/// @return The seat wide pressed button count for the key of this event 
 
 pub fn libinput_event_pointer_get_seat_button_count ( event : * mut libinput_event_pointer , ) -> u32 ; 
} extern "C" {
 
 /// @ingroup event_pointer
///
/// Check if the event has a valid value for the given axis.
///
/// If this function returns non-zero for an axis and
/// libinput_event_pointer_get_axis_value() returns a value of 0, the event
/// is a scroll stop event.
///
/// For pointer events that are not of type @ref LIBINPUT_EVENT_POINTER_AXIS,
/// this function returns 0.
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_POINTER_AXIS.
///
/// @return Non-zero if this event contains a value for this axis 
 
 pub fn libinput_event_pointer_has_axis ( event : * mut libinput_event_pointer , axis : libinput_pointer_axis , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup event_pointer
///
/// Return the axis value of the given axis. The interpretation of the value
/// depends on the axis. For the two scrolling axes
/// @ref LIBINPUT_POINTER_AXIS_SCROLL_VERTICAL and
/// @ref LIBINPUT_POINTER_AXIS_SCROLL_HORIZONTAL, the value of the event is in
/// relative scroll units, with the positive direction being down or right,
/// respectively. For the interpretation of the value, see
/// libinput_event_pointer_get_axis_source().
///
/// If libinput_event_pointer_has_axis() returns 0 for an axis, this function
/// returns 0 for that axis.
///
/// For pointer events that are not of type @ref LIBINPUT_EVENT_POINTER_AXIS,
/// this function returns 0.
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_POINTER_AXIS.
///
/// @return The axis value of this event
///
/// @see libinput_event_pointer_get_axis_value_discrete 
 
 pub fn libinput_event_pointer_get_axis_value ( event : * mut libinput_event_pointer , axis : libinput_pointer_axis , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_pointer
///
/// Return the source for a given axis event. Axis events (scroll events) can
/// be caused by a hardware item such as a scroll wheel or emulated from
/// other input sources, such as two-finger or edge scrolling on a
/// touchpad.
///
/// If the source is @ref LIBINPUT_POINTER_AXIS_SOURCE_FINGER, libinput
/// guarantees that a scroll sequence is terminated with a scroll value of 0.
/// A caller may use this information to decide on whether kinetic scrolling
/// should be triggered on this scroll sequence.
/// The coordinate system is identical to the cursor movement, i.e. a
/// scroll value of 1 represents the equivalent relative motion of 1.
///
/// If the source is @ref LIBINPUT_POINTER_AXIS_SOURCE_WHEEL, no terminating
/// event is guaranteed (though it may happen).
/// Scrolling is in discrete steps, the value is the angle the wheel moved
/// in degrees. The default is 15 degrees per wheel click, but some mice may
/// have differently grained wheels. It is up to the caller how to interpret
/// such different step sizes.
///
/// If the source is @ref LIBINPUT_POINTER_AXIS_SOURCE_CONTINUOUS, no
/// terminating event is guaranteed (though it may happen).
/// The coordinate system is identical to the cursor movement, i.e. a
/// scroll value of 1 represents the equivalent relative motion of 1.
///
/// If the source is @ref LIBINPUT_POINTER_AXIS_SOURCE_WHEEL_TILT, no
/// terminating event is guaranteed (though it may happen).
/// Scrolling is in discrete steps and there is no physical equivalent for
/// the value returned here. For backwards compatibility, the value returned
/// by this function is identical to a single mouse wheel rotation by this
/// device (see the documentation for @ref LIBINPUT_POINTER_AXIS_SOURCE_WHEEL
/// above). Callers should not use this value but instead exclusively refer
/// to the value returned by libinput_event_pointer_get_axis_value_discrete().
///
/// For pointer events that are not of type @ref LIBINPUT_EVENT_POINTER_AXIS,
/// this function returns 0.
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_POINTER_AXIS.
///
/// @return The source for this axis event 
 
 pub fn libinput_event_pointer_get_axis_source ( event : * mut libinput_event_pointer , ) -> libinput_pointer_axis_source ; 
} extern "C" {
 
 /// @ingroup event_pointer
///
/// Return the axis value in discrete steps for a given axis event. How a
/// value translates into a discrete step depends on the source.
///
/// If the source is @ref LIBINPUT_POINTER_AXIS_SOURCE_WHEEL, the discrete
/// value correspond to the number of physical mouse wheel clicks.
///
/// If the source is @ref LIBINPUT_POINTER_AXIS_SOURCE_CONTINUOUS or @ref
/// LIBINPUT_POINTER_AXIS_SOURCE_FINGER, the discrete value is always 0.
///
/// @return The discrete value for the given event.
///
/// @see libinput_event_pointer_get_axis_value 
 
 pub fn libinput_event_pointer_get_axis_value_discrete ( event : * mut libinput_event_pointer , axis : libinput_pointer_axis , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_pointer
///
/// @return The generic libinput_event of this event 
 
 pub fn libinput_event_pointer_get_base_event ( event : * mut libinput_event_pointer , ) -> * mut libinput_event ; 
} extern "C" {
 
 /// @ingroup event_touch
///
/// @note Timestamps may not always increase. See @ref event_timestamps for
/// details.
///
/// @return The event time for this event 
 
 pub fn libinput_event_touch_get_time ( event : * mut libinput_event_touch , ) -> u32 ; 
} extern "C" {
 
 /// @ingroup event_touch
///
/// @note Timestamps may not always increase. See @ref event_timestamps for
/// details.
///
/// @return The event time for this event in microseconds 
 
 pub fn libinput_event_touch_get_time_usec ( event : * mut libinput_event_touch , ) -> u64 ; 
} extern "C" {
 
 /// @ingroup event_touch
///
/// Get the slot of this touch event. See the kernel's multitouch
/// protocol B documentation for more information.
///
/// If the touch event has no assigned slot, for example if it is from a
/// single touch device, this function returns -1.
///
/// For events not of type @ref LIBINPUT_EVENT_TOUCH_DOWN, @ref
/// LIBINPUT_EVENT_TOUCH_UP, @ref LIBINPUT_EVENT_TOUCH_MOTION or @ref
/// LIBINPUT_EVENT_TOUCH_CANCEL, this function returns 0.
///
/// @note It is an application bug to call this function for events of type
/// other than @ref LIBINPUT_EVENT_TOUCH_DOWN, @ref LIBINPUT_EVENT_TOUCH_UP,
/// @ref LIBINPUT_EVENT_TOUCH_MOTION or @ref LIBINPUT_EVENT_TOUCH_CANCEL.
///
/// @return The slot of this touch event 
 
 pub fn libinput_event_touch_get_slot ( event : * mut libinput_event_touch , ) -> i32 ; 
} extern "C" {
 
 /// @ingroup event_touch
///
/// Get the seat slot of the touch event. A seat slot is a non-negative seat
/// wide unique identifier of an active touch point.
///
/// Events from single touch devices will be represented as one individual
/// touch point per device.
///
/// For events not of type @ref LIBINPUT_EVENT_TOUCH_DOWN, @ref
/// LIBINPUT_EVENT_TOUCH_UP, @ref LIBINPUT_EVENT_TOUCH_MOTION or @ref
/// LIBINPUT_EVENT_TOUCH_CANCEL, this function returns 0.
///
/// @note It is an application bug to call this function for events of type
/// other than @ref LIBINPUT_EVENT_TOUCH_DOWN, @ref LIBINPUT_EVENT_TOUCH_UP,
/// @ref LIBINPUT_EVENT_TOUCH_MOTION or @ref LIBINPUT_EVENT_TOUCH_CANCEL.
///
/// @return The seat slot of the touch event 
 
 pub fn libinput_event_touch_get_seat_slot ( event : * mut libinput_event_touch , ) -> i32 ; 
} extern "C" {
 
 /// @ingroup event_touch
///
/// Return the current absolute x coordinate of the touch event, in mm from
/// the top left corner of the device. To get the corresponding output screen
/// coordinate, use libinput_event_touch_get_x_transformed().
///
/// For events not of type @ref LIBINPUT_EVENT_TOUCH_DOWN, @ref
/// LIBINPUT_EVENT_TOUCH_MOTION, this function returns 0.
///
/// @note It is an application bug to call this function for events of type
/// other than @ref LIBINPUT_EVENT_TOUCH_DOWN or @ref
/// LIBINPUT_EVENT_TOUCH_MOTION.
///
/// @param event The libinput touch event
/// @return The current absolute x coordinate 
 
 pub fn libinput_event_touch_get_x ( event : * mut libinput_event_touch , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_touch
///
/// Return the current absolute y coordinate of the touch event, in mm from
/// the top left corner of the device. To get the corresponding output screen
/// coordinate, use libinput_event_touch_get_y_transformed().
///
/// For events not of type @ref LIBINPUT_EVENT_TOUCH_DOWN, @ref
/// LIBINPUT_EVENT_TOUCH_MOTION, this function returns 0.
///
/// @note It is an application bug to call this function for events of type
/// other than @ref LIBINPUT_EVENT_TOUCH_DOWN or @ref
/// LIBINPUT_EVENT_TOUCH_MOTION.
///
/// @param event The libinput touch event
/// @return The current absolute y coordinate 
 
 pub fn libinput_event_touch_get_y ( event : * mut libinput_event_touch , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_touch
///
/// Return the current absolute x coordinate of the touch event, transformed to
/// screen coordinates.
///
/// For events not of type @ref LIBINPUT_EVENT_TOUCH_DOWN, @ref
/// LIBINPUT_EVENT_TOUCH_MOTION, this function returns 0.
///
/// @note It is an application bug to call this function for events of type
/// other than @ref LIBINPUT_EVENT_TOUCH_DOWN or @ref
/// LIBINPUT_EVENT_TOUCH_MOTION.
///
/// @param event The libinput touch event
/// @param width The current output screen width
/// @return The current absolute x coordinate transformed to a screen coordinate 
 
 pub fn libinput_event_touch_get_x_transformed ( event : * mut libinput_event_touch , width : u32 , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_touch
///
/// Return the current absolute y coordinate of the touch event, transformed to
/// screen coordinates.
///
/// For events not of type @ref LIBINPUT_EVENT_TOUCH_DOWN, @ref
/// LIBINPUT_EVENT_TOUCH_MOTION, this function returns 0.
///
/// @note It is an application bug to call this function for events of type
/// other than @ref LIBINPUT_EVENT_TOUCH_DOWN or @ref
/// LIBINPUT_EVENT_TOUCH_MOTION.
///
/// @param event The libinput touch event
/// @param height The current output screen height
/// @return The current absolute y coordinate transformed to a screen coordinate 
 
 pub fn libinput_event_touch_get_y_transformed ( event : * mut libinput_event_touch , height : u32 , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_touch
///
/// @return The generic libinput_event of this event 
 
 pub fn libinput_event_touch_get_base_event ( event : * mut libinput_event_touch , ) -> * mut libinput_event ; 
} extern "C" {
 
 /// @ingroup event_gesture
///
/// @note Timestamps may not always increase. See @ref event_timestamps for
/// details.
///
/// @return The event time for this event 
 
 pub fn libinput_event_gesture_get_time ( event : * mut libinput_event_gesture , ) -> u32 ; 
} extern "C" {
 
 /// @ingroup event_gesture
///
/// @note Timestamps may not always increase. See @ref event_timestamps for
/// details.
///
/// @return The event time for this event in microseconds 
 
 pub fn libinput_event_gesture_get_time_usec ( event : * mut libinput_event_gesture , ) -> u64 ; 
} extern "C" {
 
 /// @ingroup event_gesture
///
/// @return The generic libinput_event of this event 
 
 pub fn libinput_event_gesture_get_base_event ( event : * mut libinput_event_gesture , ) -> * mut libinput_event ; 
} extern "C" {
 
 /// @ingroup event_gesture
///
/// Return the number of fingers used for a gesture. This can be used e.g.
/// to differentiate between 3 or 4 finger swipes.
///
/// This function can be called on all gesture events and the returned finger
/// count value will not change during a sequence.
///
/// @return the number of fingers used for a gesture 
 
 pub fn libinput_event_gesture_get_finger_count ( event : * mut libinput_event_gesture , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup event_gesture
///
/// Return if the gesture ended normally, or if it was cancelled.
/// For gesture events that are not of type
/// @ref LIBINPUT_EVENT_GESTURE_SWIPE_END or
/// @ref LIBINPUT_EVENT_GESTURE_PINCH_END, this function returns 0.
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_GESTURE_SWIPE_END or
/// @ref LIBINPUT_EVENT_GESTURE_PINCH_END.
///
/// @return 0 or 1, with 1 indicating that the gesture was cancelled. 
 
 pub fn libinput_event_gesture_get_cancelled ( event : * mut libinput_event_gesture , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup event_gesture
///
/// Return the delta between the last event and the current event. For gesture
/// events that are not of type @ref LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE or
/// @ref LIBINPUT_EVENT_GESTURE_PINCH_UPDATE, this function returns 0.
///
/// If a device employs pointer acceleration, the delta returned by this
/// function is the accelerated delta.
///
/// Relative motion deltas are normalized to represent those of a device with
/// 1000dpi resolution. See @ref motion_normalization for more details.
///
/// @return the relative x movement since the last event 
 
 pub fn libinput_event_gesture_get_dx ( event : * mut libinput_event_gesture , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_gesture
///
/// Return the delta between the last event and the current event. For gesture
/// events that are not of type @ref LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE or
/// @ref LIBINPUT_EVENT_GESTURE_PINCH_UPDATE, this function returns 0.
///
/// If a device employs pointer acceleration, the delta returned by this
/// function is the accelerated delta.
///
/// Relative motion deltas are normalized to represent those of a device with
/// 1000dpi resolution. See @ref motion_normalization for more details.
///
/// @return the relative y movement since the last event 
 
 pub fn libinput_event_gesture_get_dy ( event : * mut libinput_event_gesture , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_gesture
///
/// Return the relative delta of the unaccelerated motion vector of the
/// current event. For gesture events that are not of type
/// @ref LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE or
/// @ref LIBINPUT_EVENT_GESTURE_PINCH_UPDATE, this function returns 0.
///
/// Relative unaccelerated motion deltas are normalized to represent those of a
/// device with 1000dpi resolution. See @ref motion_normalization for more
/// details. Note that unaccelerated events are not equivalent to 'raw' events
/// as read from the device.
///
/// Any rotation applied to the device also applies to gesture motion
/// (see libinput_device_config_rotation_set_angle()).
///
/// @return the unaccelerated relative x movement since the last event 
 
 pub fn libinput_event_gesture_get_dx_unaccelerated ( event : * mut libinput_event_gesture , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_gesture
///
/// Return the relative delta of the unaccelerated motion vector of the
/// current event. For gesture events that are not of type
/// @ref LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE or
/// @ref LIBINPUT_EVENT_GESTURE_PINCH_UPDATE, this function returns 0.
///
/// Relative unaccelerated motion deltas are normalized to represent those of a
/// device with 1000dpi resolution. See @ref motion_normalization for more
/// details. Note that unaccelerated events are not equivalent to 'raw' events
/// as read from the device.
///
/// Any rotation applied to the device also applies to gesture motion
/// (see libinput_device_config_rotation_set_angle()).
///
/// @return the unaccelerated relative y movement since the last event 
 
 pub fn libinput_event_gesture_get_dy_unaccelerated ( event : * mut libinput_event_gesture , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_gesture
///
/// Return the absolute scale of a pinch gesture, the scale is the division
/// of the current distance between the fingers and the distance at the start
/// of the gesture. The scale begins at 1.0, and if e.g. the fingers moved
/// together by 50% then the scale will become 0.5, if they move twice as far
/// apart as initially the scale becomes 2.0, etc.
///
/// For gesture events that are of type @ref
/// LIBINPUT_EVENT_GESTURE_PINCH_BEGIN, this function returns 1.0.
///
/// For gesture events that are of type @ref
/// LIBINPUT_EVENT_GESTURE_PINCH_END, this function returns the scale value
/// of the most recent @ref LIBINPUT_EVENT_GESTURE_PINCH_UPDATE event (if
/// any) or 1.0 otherwise.
///
/// For all other events this function returns 0.
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_GESTURE_PINCH_BEGIN, @ref
/// LIBINPUT_EVENT_GESTURE_PINCH_END or
/// @ref LIBINPUT_EVENT_GESTURE_PINCH_UPDATE.
///
/// @return the absolute scale of a pinch gesture 
 
 pub fn libinput_event_gesture_get_scale ( event : * mut libinput_event_gesture , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_gesture
///
/// Return the angle delta in degrees between the last and the current @ref
/// LIBINPUT_EVENT_GESTURE_PINCH_UPDATE event. For gesture events that
/// are not of type @ref LIBINPUT_EVENT_GESTURE_PINCH_UPDATE, this
/// function returns 0.
///
/// The angle delta is defined as the change in angle of the line formed by
/// the 2 fingers of a pinch gesture. Clockwise rotation is represented
/// by a positive delta, counter-clockwise by a negative delta. If e.g. the
/// fingers are on the 12 and 6 location of a clock face plate and they move
/// to the 1 resp. 7 location in a single event then the angle delta is
/// 30 degrees.
///
/// If more than two fingers are present, the angle represents the rotation
/// around the center of gravity. The calculation of the center of gravity is
/// implementation-dependent.
///
/// @return the angle delta since the last event 
 
 pub fn libinput_event_gesture_get_angle_delta ( event : * mut libinput_event_gesture , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// @return The generic libinput_event of this event 
 
 pub fn libinput_event_tablet_tool_get_base_event ( event : * mut libinput_event_tablet_tool , ) -> * mut libinput_event ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Check if the x axis was updated in this event.
/// For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
/// @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
/// @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
///
/// @note It is an application bug to call this function for events other
/// than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
/// LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
/// LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
/// LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
///
/// @param event The libinput tablet tool event
/// @return 1 if the axis was updated or 0 otherwise 
 
 pub fn libinput_event_tablet_tool_x_has_changed ( event : * mut libinput_event_tablet_tool , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Check if the y axis was updated in this event.
/// For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
/// @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
/// @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
///
/// @note It is an application bug to call this function for events other
/// than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
/// LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
/// LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
/// LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
///
/// @param event The libinput tablet tool event
/// @return 1 if the axis was updated or 0 otherwise 
 
 pub fn libinput_event_tablet_tool_y_has_changed ( event : * mut libinput_event_tablet_tool , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Check if the pressure axis was updated in this event.
/// For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
/// @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
/// @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
///
/// @note It is an application bug to call this function for events other
/// than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
/// LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
/// LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
/// LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
///
/// @param event The libinput tablet tool event
/// @return 1 if the axis was updated or 0 otherwise 
 
 pub fn libinput_event_tablet_tool_pressure_has_changed ( event : * mut libinput_event_tablet_tool , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Check if the distance axis was updated in this event.
/// For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
/// @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
/// @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
/// For tablet tool events of type @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY,
/// this function always returns 1.
///
/// @note It is an application bug to call this function for events other
/// than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
/// LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
/// LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
/// LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
///
/// @param event The libinput tablet tool event
/// @return 1 if the axis was updated or 0 otherwise 
 
 pub fn libinput_event_tablet_tool_distance_has_changed ( event : * mut libinput_event_tablet_tool , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Check if the tilt x axis was updated in this event.
/// For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
/// @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
/// @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
///
/// @note It is an application bug to call this function for events other
/// than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
/// LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
/// LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
/// LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
///
/// @param event The libinput tablet tool event
/// @return 1 if the axis was updated or 0 otherwise 
 
 pub fn libinput_event_tablet_tool_tilt_x_has_changed ( event : * mut libinput_event_tablet_tool , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Check if the tilt y axis was updated in this event.
/// For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
/// @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
/// @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
///
/// @note It is an application bug to call this function for events other
/// than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
/// LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
/// LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
/// LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
///
/// @param event The libinput tablet tool event
/// @return 1 if the axis was updated or 0 otherwise 
 
 pub fn libinput_event_tablet_tool_tilt_y_has_changed ( event : * mut libinput_event_tablet_tool , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Check if the z-rotation axis was updated in this event.
/// For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
/// @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
/// @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
///
/// @note It is an application bug to call this function for events other
/// than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
/// LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
/// LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
/// LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
///
/// @param event The libinput tablet tool event
/// @return 1 if the axis was updated or 0 otherwise 
 
 pub fn libinput_event_tablet_tool_rotation_has_changed ( event : * mut libinput_event_tablet_tool , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Check if the slider axis was updated in this event.
/// For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
/// @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
/// @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
///
/// @note It is an application bug to call this function for events other
/// than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
/// LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
/// LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
/// LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
///
/// @param event The libinput tablet tool event
/// @return 1 if the axis was updated or 0 otherwise 
 
 pub fn libinput_event_tablet_tool_slider_has_changed ( event : * mut libinput_event_tablet_tool , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Check if the wheel axis was updated in this event.
/// For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
/// @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
/// @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
///
/// @note It is an application bug to call this function for events other
/// than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
/// LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
/// LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
/// LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
///
/// @param event The libinput tablet tool event
/// @return 1 if the axis was updated or 0 otherwise 
 
 pub fn libinput_event_tablet_tool_wheel_has_changed ( event : * mut libinput_event_tablet_tool , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Returns the X coordinate of the tablet tool, in mm from the top left
/// corner of the tablet in its current logical orientation. Use
/// libinput_event_tablet_tool_get_x_transformed() for transforming the axis
/// value into a different coordinate space.
///
/// @note On some devices, returned value may be negative or larger than the
/// width of the device. See @ref tablet-bounds for more details.
///
/// @param event The libinput tablet tool event
/// @return The current value of the the axis 
 
 pub fn libinput_event_tablet_tool_get_x ( event : * mut libinput_event_tablet_tool , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Returns the Y coordinate of the tablet tool, in mm from the top left
/// corner of the tablet in its current logical orientation. Use
/// libinput_event_tablet_tool_get_y_transformed() for transforming the axis
/// value into a different coordinate space.
///
/// @note On some devices, returned value may be negative or larger than the
/// width of the device. See @ref tablet-bounds for more details.
///
/// @param event The libinput tablet tool event
/// @return The current value of the the axis 
 
 pub fn libinput_event_tablet_tool_get_y ( event : * mut libinput_event_tablet_tool , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Return the delta between the last event and the current event.
/// If the tool employs pointer acceleration, the delta returned by this
/// function is the accelerated delta.
///
/// This value is in screen coordinate space, the delta is to be interpreted
/// like the return value of libinput_event_pointer_get_dx().
/// See @ref tablet-relative-motion for more details.
///
/// @param event The libinput tablet event
/// @return The relative x movement since the last event 
 
 pub fn libinput_event_tablet_tool_get_dx ( event : * mut libinput_event_tablet_tool , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Return the delta between the last event and the current event.
/// If the tool employs pointer acceleration, the delta returned by this
/// function is the accelerated delta.
///
/// This value is in screen coordinate space, the delta is to be interpreted
/// like the return value of libinput_event_pointer_get_dx().
/// See @ref tablet-relative-motion for more details.
///
/// @param event The libinput tablet event
/// @return The relative y movement since the last event 
 
 pub fn libinput_event_tablet_tool_get_dy ( event : * mut libinput_event_tablet_tool , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Returns the current pressure being applied on the tool in use, normalized
/// to the range [0, 1].
///
/// If this axis does not exist on the current tool, this function returns 0.
///
/// @param event The libinput tablet tool event
/// @return The current value of the the axis 
 
 pub fn libinput_event_tablet_tool_get_pressure ( event : * mut libinput_event_tablet_tool , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Returns the current distance from the tablet's sensor, normalized to the
/// range [0, 1].
///
/// If this axis does not exist on the current tool, this function returns 0.
///
/// @param event The libinput tablet tool event
/// @return The current value of the the axis 
 
 pub fn libinput_event_tablet_tool_get_distance ( event : * mut libinput_event_tablet_tool , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Returns the current tilt along the X axis of the tablet's current logical
/// orientation, in degrees off the tablet's z axis. That is, if the tool is
/// perfectly orthogonal to the tablet, the tilt angle is 0. When the top
/// tilts towards the logical top/left of the tablet, the x/y tilt angles are
/// negative, if the top tilts towards the logical bottom/right of the
/// tablet, the x/y tilt angles are positive.
///
/// If this axis does not exist on the current tool, this function returns 0.
///
/// @param event The libinput tablet tool event
/// @return The current value of the axis in degrees 
 
 pub fn libinput_event_tablet_tool_get_tilt_x ( event : * mut libinput_event_tablet_tool , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Returns the current tilt along the Y axis of the tablet's current logical
/// orientation, in degrees off the tablet's z axis. That is, if the tool is
/// perfectly orthogonal to the tablet, the tilt angle is 0. When the top
/// tilts towards the logical top/left of the tablet, the x/y tilt angles are
/// negative, if the top tilts towards the logical bottom/right of the
/// tablet, the x/y tilt angles are positive.
///
/// If this axis does not exist on the current tool, this function returns 0.
///
/// @param event The libinput tablet tool event
/// @return The current value of the the axis in degrees 
 
 pub fn libinput_event_tablet_tool_get_tilt_y ( event : * mut libinput_event_tablet_tool , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Returns the current z rotation of the tool in degrees, clockwise from the
/// tool's logical neutral position.
///
/// For tools of type @ref LIBINPUT_TABLET_TOOL_TYPE_MOUSE and @ref
/// LIBINPUT_TABLET_TOOL_TYPE_LENS the logical neutral position is
/// pointing to the current logical north of the tablet. For tools of type @ref
/// LIBINPUT_TABLET_TOOL_TYPE_BRUSH, the logical neutral position is with the
/// buttons pointing up.
///
/// If this axis does not exist on the current tool, this function returns 0.
///
/// @param event The libinput tablet tool event
/// @return The current value of the the axis 
 
 pub fn libinput_event_tablet_tool_get_rotation ( event : * mut libinput_event_tablet_tool , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Returns the current position of the slider on the tool, normalized to the
/// range [-1, 1]. The logical zero is the neutral position of the slider, or
/// the logical center of the axis. This axis is available on e.g. the Wacom
/// Airbrush.
///
/// If this axis does not exist on the current tool, this function returns 0.
///
/// @param event The libinput tablet tool event
/// @return The current value of the the axis 
 
 pub fn libinput_event_tablet_tool_get_slider_position ( event : * mut libinput_event_tablet_tool , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Return the delta for the wheel in degrees.
///
/// @param event The libinput tablet tool event
/// @return The delta of the wheel, in degrees, compared to the last event
///
/// @see libinput_event_tablet_tool_get_wheel_delta_discrete 
 
 pub fn libinput_event_tablet_tool_get_wheel_delta ( event : * mut libinput_event_tablet_tool , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Return the delta for the wheel in discrete steps (e.g. wheel clicks).
///
/// @param event The libinput tablet tool event
/// @return The delta of the wheel, in discrete steps, compared to the last event
///
/// @see libinput_event_tablet_tool_get_wheel_delta_discrete 
 
 pub fn libinput_event_tablet_tool_get_wheel_delta_discrete ( event : * mut libinput_event_tablet_tool , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Return the current absolute x coordinate of the tablet tool event,
/// transformed to screen coordinates.
///
/// @note This function may be called for a specific axis even if
/// libinput_event_tablet_tool_*_has_changed() returns 0 for that axis.
/// libinput always includes all device axes in the event.
///
/// @note On some devices, returned value may be negative or larger than the
/// width of the device. See @ref tablet-bounds for more details.
///
/// @param event The libinput tablet tool event
/// @param width The current output screen width
/// @return the current absolute x coordinate transformed to a screen coordinate 
 
 pub fn libinput_event_tablet_tool_get_x_transformed ( event : * mut libinput_event_tablet_tool , width : u32 , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Return the current absolute y coordinate of the tablet tool event,
/// transformed to screen coordinates.
///
/// @note This function may be called for a specific axis even if
/// libinput_event_tablet_tool_*_has_changed() returns 0 for that axis.
/// libinput always includes all device axes in the event.
///
/// @note On some devices, returned value may be negative or larger than the
/// width of the device. See @ref tablet-bounds for more details.
///
/// @param event The libinput tablet tool event
/// @param height The current output screen height
/// @return the current absolute y coordinate transformed to a screen coordinate 
 
 pub fn libinput_event_tablet_tool_get_y_transformed ( event : * mut libinput_event_tablet_tool , height : u32 , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Returns the tool that was in use during this event.
///
/// The returned tablet tool is not refcounted and may become invalid after
/// the next call to libinput. Use libinput_tablet_tool_ref() and
/// libinput_tablet_tool_unref() to continue using the handle outside of the
/// immediate scope.
///
/// If the caller holds at least one reference, this struct is used
/// whenever the tools enters proximity again.
///
/// @note Physical tool tracking requires hardware support. If unavailable,
/// libinput creates one tool per type per tablet. See @ref
/// tablet-serial-numbers for more details.
///
/// @param event The libinput tablet tool event
/// @return The new tool triggering this event 
 
 pub fn libinput_event_tablet_tool_get_tool ( event : * mut libinput_event_tablet_tool , ) -> * mut libinput_tablet_tool ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Returns the new proximity state of a tool from a proximity event.
/// Used to check whether or not a tool came in or out of proximity during an
/// event of type @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY.
///
/// See @ref tablet-fake-proximity for recommendations on proximity handling.
///
/// @param event The libinput tablet tool event
/// @return The new proximity state of the tool from the event. 
 
 pub fn libinput_event_tablet_tool_get_proximity_state ( event : * mut libinput_event_tablet_tool , ) -> libinput_tablet_tool_proximity_state ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Returns the new tip state of a tool from a tip event.
/// Used to check whether or not a tool came in contact with the tablet
/// surface or left contact with the tablet surface during an
/// event of type @ref LIBINPUT_EVENT_TABLET_TOOL_TIP.
///
/// @param event The libinput tablet tool event
/// @return The new tip state of the tool from the event. 
 
 pub fn libinput_event_tablet_tool_get_tip_state ( event : * mut libinput_event_tablet_tool , ) -> libinput_tablet_tool_tip_state ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Return the button that triggered this event.  For events that are not of
/// type @ref LIBINPUT_EVENT_TABLET_TOOL_BUTTON, this function returns 0.
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
///
/// @param event The libinput tablet tool event
/// @return the button triggering this event 
 
 pub fn libinput_event_tablet_tool_get_button ( event : * mut libinput_event_tablet_tool , ) -> u32 ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Return the button state of the event.
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
///
/// @param event The libinput tablet tool event
/// @return the button state triggering this event 
 
 pub fn libinput_event_tablet_tool_get_button_state ( event : * mut libinput_event_tablet_tool , ) -> libinput_button_state ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// For the button of a @ref LIBINPUT_EVENT_TABLET_TOOL_BUTTON event, return the total
/// number of buttons pressed on all devices on the associated seat after the
/// the event was triggered.
///
/// " @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_TABLET_TOOL_BUTTON. For other events, this function returns 0.
///
/// @param event The libinput tablet tool event
/// @return the seat wide pressed button count for the key of this event 
 
 pub fn libinput_event_tablet_tool_get_seat_button_count ( event : * mut libinput_event_tablet_tool , ) -> u32 ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// @note Timestamps may not always increase. See @ref event_timestamps for
/// details.
///
/// @param event The libinput tablet tool event
/// @return The event time for this event 
 
 pub fn libinput_event_tablet_tool_get_time ( event : * mut libinput_event_tablet_tool , ) -> u32 ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// @note Timestamps may not always increase. See @ref event_timestamps for
/// details.
///
/// @param event The libinput tablet tool event
/// @return The event time for this event in microseconds 
 
 pub fn libinput_event_tablet_tool_get_time_usec ( event : * mut libinput_event_tablet_tool , ) -> u64 ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Return the tool type for a tool object, see @ref
/// tablet-tool-types for details.
///
/// @param tool The libinput tool
/// @return The tool type for this tool object
///
/// @see libinput_tablet_tool_get_tool_id 
 
 pub fn libinput_tablet_tool_get_type ( tool : * mut libinput_tablet_tool , ) -> libinput_tablet_tool_type ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Return the tool ID for a tool object. If nonzero, this number identifies
/// the specific type of the tool with more precision than the type returned in
/// libinput_tablet_tool_get_type(), see @ref tablet-tool-types. Not all
/// tablets support a tool ID.
///
/// Tablets known to support tool IDs include the Wacom Intuos 3, 4, 5, Wacom
/// Cintiq and Wacom Intuos Pro series.
///
/// @param tool The libinput tool
/// @return The tool ID for this tool object or 0 if none is provided
///
/// @see libinput_tablet_tool_get_type 
 
 pub fn libinput_tablet_tool_get_tool_id ( tool : * mut libinput_tablet_tool , ) -> u64 ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Increment the reference count of the tool by one. A tool is destroyed
/// whenever the reference count reaches 0. See libinput_tablet_tool_unref().
///
/// @param tool The tool to increment the ref count of
/// @return The passed tool
///
/// @see libinput_tablet_tool_unref 
 
 pub fn libinput_tablet_tool_ref ( tool : * mut libinput_tablet_tool , ) -> * mut libinput_tablet_tool ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Decrement the reference count of the tool by one. When the reference
/// count of the tool reaches 0, the memory allocated for the tool will be
/// freed.
///
/// @param tool The tool to decrement the ref count of
/// @return NULL if the tool was destroyed otherwise the passed tool
///
/// @see libinput_tablet_tool_ref 
 
 pub fn libinput_tablet_tool_unref ( tool : * mut libinput_tablet_tool , ) -> * mut libinput_tablet_tool ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Return whether the tablet tool supports pressure.
///
/// @param tool The tool to check the axis capabilities of
/// @return Nonzero if the axis is available, zero otherwise. 
 
 pub fn libinput_tablet_tool_has_pressure ( tool : * mut libinput_tablet_tool , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Return whether the tablet tool supports distance.
///
/// @param tool The tool to check the axis capabilities of
/// @return Nonzero if the axis is available, zero otherwise. 
 
 pub fn libinput_tablet_tool_has_distance ( tool : * mut libinput_tablet_tool , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Return whether the tablet tool supports tilt.
///
/// @param tool The tool to check the axis capabilities of
/// @return Nonzero if the axis is available, zero otherwise. 
 
 pub fn libinput_tablet_tool_has_tilt ( tool : * mut libinput_tablet_tool , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Return whether the tablet tool supports z-rotation.
///
/// @param tool The tool to check the axis capabilities of
/// @return Nonzero if the axis is available, zero otherwise. 
 
 pub fn libinput_tablet_tool_has_rotation ( tool : * mut libinput_tablet_tool , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Return whether the tablet tool has a slider axis.
///
/// @param tool The tool to check the axis capabilities of
/// @return Nonzero if the axis is available, zero otherwise. 
 
 pub fn libinput_tablet_tool_has_slider ( tool : * mut libinput_tablet_tool , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Return whether the tablet tool has a relative wheel.
///
/// @param tool The tool to check the axis capabilities of
/// @return Nonzero if the axis is available, zero otherwise. 
 
 pub fn libinput_tablet_tool_has_wheel ( tool : * mut libinput_tablet_tool , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Check if a tablet tool has a button with the
/// passed-in code (see linux/input.h).
///
/// @param tool A tablet tool
/// @param code button code to check for
///
/// @return 1 if the tool supports this button code, 0 if it does not 
 
 pub fn libinput_tablet_tool_has_button ( tool : * mut libinput_tablet_tool , code : u32 , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Return nonzero if the physical tool can be uniquely identified by
/// libinput, or nonzero otherwise. If a tool can be uniquely identified,
/// keeping a reference to the tool allows tracking the tool across
/// proximity out sequences and across compatible tablets.
/// See @ref tablet-serial-numbers for more details.
///
/// @param tool A tablet tool
/// @return 1 if the tool can be uniquely identified, 0 otherwise.
///
/// @see libinput_tablet_tool_get_serial 
 
 pub fn libinput_tablet_tool_is_unique ( tool : * mut libinput_tablet_tool , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Return the serial number of a tool. If the tool does not report a serial
/// number, this function returns zero. See @ref tablet-serial-numbers for
/// details.
///
/// @param tool The libinput tool
/// @return The tool serial number
///
/// @see libinput_tablet_tool_is_unique 
 
 pub fn libinput_tablet_tool_get_serial ( tool : * mut libinput_tablet_tool , ) -> u64 ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Return the user data associated with a tool object. libinput does
/// not manage, look at, or modify this data. The caller must ensure the
/// data is valid.
///
/// @param tool The libinput tool
/// @return The user data associated with the tool object 
 
 pub fn libinput_tablet_tool_get_user_data ( tool : * mut libinput_tablet_tool , ) -> * mut ::libc :: c_void ; 
} extern "C" {
 
 /// @ingroup event_tablet
///
/// Set the user data associated with a tool object, if any.
///
/// @param tool The libinput tool
/// @param user_data The user data to associate with the tool object 
 
 pub fn libinput_tablet_tool_set_user_data ( tool : * mut libinput_tablet_tool , user_data : * mut ::libc :: c_void , ) ; 
} extern "C" {
 
 /// @ingroup event_tablet_pad
///
/// @return The generic libinput_event of this event 
 
 pub fn libinput_event_tablet_pad_get_base_event ( event : * mut libinput_event_tablet_pad , ) -> * mut libinput_event ; 
} extern "C" {
 
 /// @ingroup event_tablet_pad
///
/// Returns the current position of the ring, in degrees counterclockwise
/// from the northern-most point of the ring in the tablet's current logical
/// orientation.
///
/// If the source is @ref LIBINPUT_TABLET_PAD_RING_SOURCE_FINGER,
/// libinput sends a terminating event with a ring value of -1 when the
/// finger is lifted from the ring. A caller may use this information to e.g.
/// determine if kinetic scrolling should be triggered.
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_TABLET_PAD_RING.  For other events, this function
/// returns 0.
///
/// @param event The libinput tablet pad event
/// @return The current value of the the axis
/// @retval -1 The finger was lifted 
 
 pub fn libinput_event_tablet_pad_get_ring_position ( event : * mut libinput_event_tablet_pad , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_tablet_pad
///
/// Returns the number of the ring that has changed state, with 0 being the
/// first ring. On tablets with only one ring, this function always returns
/// 0.
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_TABLET_PAD_RING.  For other events, this function
/// returns 0.
///
/// @param event The libinput tablet pad event
/// @return The index of the ring that changed state 
 
 pub fn libinput_event_tablet_pad_get_ring_number ( event : * mut libinput_event_tablet_pad , ) -> ::libc :: c_uint ; 
} extern "C" {
 
 /// @ingroup event_tablet_pad
///
/// Returns the source of the interaction with the ring. If the source is
/// @ref LIBINPUT_TABLET_PAD_RING_SOURCE_FINGER, libinput sends a ring
/// position value of -1 to terminate the current interaction.
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_TABLET_PAD_RING.  For other events, this function
/// returns 0.
///
/// @param event The libinput tablet pad event
/// @return The source of the ring interaction 
 
 pub fn libinput_event_tablet_pad_get_ring_source ( event : * mut libinput_event_tablet_pad , ) -> libinput_tablet_pad_ring_axis_source ; 
} extern "C" {
 
 /// @ingroup event_tablet_pad
///
/// Returns the current position of the strip, normalized to the range
/// [0, 1], with 0 being the top/left-most point in the tablet's current
/// logical orientation.
///
/// If the source is @ref LIBINPUT_TABLET_PAD_STRIP_SOURCE_FINGER,
/// libinput sends a terminating event with a ring value of -1 when the
/// finger is lifted from the ring. A caller may use this information to e.g.
/// determine if kinetic scrolling should be triggered.
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_TABLET_PAD_STRIP.  For other events, this function
/// returns 0.
///
/// @param event The libinput tablet pad event
/// @return The current value of the the axis
/// @retval -1 The finger was lifted 
 
 pub fn libinput_event_tablet_pad_get_strip_position ( event : * mut libinput_event_tablet_pad , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup event_tablet_pad
///
/// Returns the number of the strip that has changed state, with 0 being the
/// first strip. On tablets with only one strip, this function always returns
/// 0.
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_TABLET_PAD_STRIP.  For other events, this function
/// returns 0.
///
/// @param event The libinput tablet pad event
/// @return The index of the strip that changed state 
 
 pub fn libinput_event_tablet_pad_get_strip_number ( event : * mut libinput_event_tablet_pad , ) -> ::libc :: c_uint ; 
} extern "C" {
 
 /// @ingroup event_tablet_pad
///
/// Returns the source of the interaction with the strip. If the source is
/// @ref LIBINPUT_TABLET_PAD_STRIP_SOURCE_FINGER, libinput sends a strip
/// position value of -1 to terminate the current interaction.
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_TABLET_PAD_STRIP.  For other events, this function
/// returns 0.
///
/// @param event The libinput tablet pad event
/// @return The source of the strip interaction 
 
 pub fn libinput_event_tablet_pad_get_strip_source ( event : * mut libinput_event_tablet_pad , ) -> libinput_tablet_pad_strip_axis_source ; 
} extern "C" {
 
 /// @ingroup event_tablet_pad
///
/// Return the button number that triggered this event, starting at 0.
/// For events that are not of type @ref LIBINPUT_EVENT_TABLET_PAD_BUTTON,
/// this function returns 0.
///
/// Note that the number returned is a generic sequential button number and
/// not a semantic button code as defined in linux/input.h.
/// See @ref tablet-pad-buttons for more details.
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_TABLET_PAD_BUTTON. For other events, this function
/// returns 0.
///
/// @param event The libinput tablet pad event
/// @return the button triggering this event 
 
 pub fn libinput_event_tablet_pad_get_button_number ( event : * mut libinput_event_tablet_pad , ) -> u32 ; 
} extern "C" {
 
 /// @ingroup event_tablet_pad
///
/// Return the button state of the event.
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_TABLET_PAD_BUTTON. For other events, this function
/// returns 0.
///
/// @param event The libinput tablet pad event
/// @return the button state triggering this event 
 
 pub fn libinput_event_tablet_pad_get_button_state ( event : * mut libinput_event_tablet_pad , ) -> libinput_button_state ; 
} extern "C" {
 
 /// @ingroup event_tablet_pad
///
/// Returns the mode the button, ring, or strip that triggered this event is
/// in, at the time of the event.
///
/// The mode is a virtual grouping of functionality, usually based on some
/// visual feedback like LEDs on the pad. See @ref tablet-pad-modes for
/// details. Mode indices start at 0, a device that does not support modes
/// always returns 0.
///
/// Mode switching is controlled by libinput and more than one mode may exist
/// on the tablet. This function returns the mode that this event's button,
/// ring or strip is logically in. If the button is a mode toggle button
/// and the button event caused a new mode to be toggled, the mode returned
/// is the new mode the button is in.
///
/// Note that the returned mode is the mode valid as of the time of the
/// event. The returned mode may thus be different to the mode returned by
/// libinput_tablet_pad_mode_group_get_mode(). See
/// libinput_tablet_pad_mode_group_get_mode() for details.
///
/// @param event The libinput tablet pad event
/// @return the 0-indexed mode of this button, ring or strip at the time of
/// the event
///
/// @see libinput_tablet_pad_mode_group_get_mode 
 
 pub fn libinput_event_tablet_pad_get_mode ( event : * mut libinput_event_tablet_pad , ) -> ::libc :: c_uint ; 
} extern "C" {
 
 /// @ingroup event_tablet_pad
///
/// Returns the mode group that the button, ring, or strip that triggered
/// this event is considered in. The mode is a virtual grouping of
/// functionality, usually based on some visual feedback like LEDs on the
/// pad. See @ref tablet-pad-modes for details.
///
/// The returned mode group is not refcounted and may become invalid after
/// the next call to libinput. Use libinput_tablet_pad_mode_group_ref() and
/// libinput_tablet_pad_mode_group_unref() to continue using the handle
/// outside of the immediate scope.
///
/// @param event The libinput tablet pad event
/// @return the mode group of the button, ring or strip that caused this event
///
/// @see libinput_device_tablet_pad_get_mode_group 
 
 pub fn libinput_event_tablet_pad_get_mode_group ( event : * mut libinput_event_tablet_pad , ) -> * mut libinput_tablet_pad_mode_group ; 
} extern "C" {
 
 /// @ingroup event_tablet_pad
///
/// @note Timestamps may not always increase. See @ref event_timestamps for
/// details.
///
/// @param event The libinput tablet pad event
/// @return The event time for this event 
 
 pub fn libinput_event_tablet_pad_get_time ( event : * mut libinput_event_tablet_pad , ) -> u32 ; 
} extern "C" {
 
 /// @ingroup event_tablet_pad
///
/// @note Timestamps may not always increase. See @ref event_timestamps for
/// details.
///
/// @param event The libinput tablet pad event
/// @return The event time for this event in microseconds 
 
 pub fn libinput_event_tablet_pad_get_time_usec ( event : * mut libinput_event_tablet_pad , ) -> u64 ; 
} extern "C" {
 
 /// @ingroup event_switch
///
/// Return the switch that triggered this event.
/// For pointer events that are not of type @ref
/// LIBINPUT_EVENT_SWITCH_TOGGLE, this function returns 0.
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_SWITCH_TOGGLE.
///
/// @param event The libinput switch event
/// @return The switch triggering this event 
 
 pub fn libinput_event_switch_get_switch ( event : * mut libinput_event_switch , ) -> libinput_switch ; 
} extern "C" {
 
 /// @ingroup event_switch
///
/// Return the switch state that triggered this event.
/// For switch events that are not of type @ref
/// LIBINPUT_EVENT_SWITCH_TOGGLE, this function returns 0.
///
/// @note It is an application bug to call this function for events other than
/// @ref LIBINPUT_EVENT_SWITCH_TOGGLE.
///
/// @param event The libinput switch event
/// @return The switch state triggering this event 
 
 pub fn libinput_event_switch_get_switch_state ( event : * mut libinput_event_switch , ) -> libinput_switch_state ; 
} extern "C" {
 
 /// @ingroup event_switch
///
/// @return The generic libinput_event of this event 
 
 pub fn libinput_event_switch_get_base_event ( event : * mut libinput_event_switch , ) -> * mut libinput_event ; 
} extern "C" {
 
 /// @ingroup event_switch
///
/// @note Timestamps may not always increase. See @ref event_timestamps for
/// details.
///
/// @param event The libinput switch event
/// @return The event time for this event 
 
 pub fn libinput_event_switch_get_time ( event : * mut libinput_event_switch , ) -> u32 ; 
} extern "C" {
 
 /// @ingroup event_switch
///
/// @note Timestamps may not always increase. See @ref event_timestamps for
/// details.
///
/// @param event The libinput switch event
/// @return The event time for this event in microseconds 
 
 pub fn libinput_event_switch_get_time_usec ( event : * mut libinput_event_switch , ) -> u64 ; 
} 
 /// @ingroup base
/// @struct libinput_interface
///
/// libinput does not open file descriptors to devices directly, instead
/// open_restricted() and close_restricted() are called for each path that
/// must be opened.
///
/// @see libinput_udev_create_context
/// @see libinput_path_create_context 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct libinput_interface { 
 /// Open the device at the given path with the flags provided and
    /// return the fd.
    ///
    /// @param path The device path to open
    /// @param flags Flags as defined by open(2)
    /// @param user_data The user_data provided in
    /// libinput_udev_create_context()
    ///
    /// @return The file descriptor, or a negative errno on failure. 
 pub open_restricted : :: std :: option :: Option < unsafe extern "C" fn ( path : * const ::libc :: c_char , flags : ::libc :: c_int , user_data : * mut ::libc :: c_void ) -> ::libc :: c_int > , 
 /// Close the file descriptor.
    ///
    /// @param fd The file descriptor to close
    /// @param user_data The user_data provided in
    /// libinput_udev_create_context() 
 pub close_restricted : :: std :: option :: Option < unsafe extern "C" fn ( fd : ::libc :: c_int , user_data : * mut ::libc :: c_void ) > , } # [ test ] fn bindgen_test_layout_libinput_interface ( ) { assert_eq ! ( :: std :: mem :: size_of :: < libinput_interface > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( libinput_interface ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < libinput_interface > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( libinput_interface ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const libinput_interface ) ) . open_restricted as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( libinput_interface ) , "::" , stringify ! ( open_restricted ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const libinput_interface ) ) . close_restricted as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( libinput_interface ) , "::" , stringify ! ( close_restricted ) ) ) ; } extern "C" {
 
 /// @ingroup base
///
/// Create a new libinput context from udev. This context is inactive until
/// assigned a seat ID with libinput_udev_assign_seat().
///
/// @param interface The callback interface
/// @param user_data Caller-specific data passed to the various callback
/// interfaces.
/// @param udev An already initialized udev context
///
/// @return An initialized, but inactive libinput context or NULL on error 
 
 pub fn libinput_udev_create_context ( interface : * const libinput_interface , user_data : * mut ::libc :: c_void , udev : * mut udev , ) -> * mut libinput ; 
} extern "C" {
 
 /// @ingroup base
///
/// Assign a seat to this libinput context. New devices or the removal of
/// existing devices will appear as events during libinput_dispatch().
///
/// libinput_udev_assign_seat() succeeds even if no input devices are currently
/// available on this seat, or if devices are available but fail to open in
/// @ref libinput_interface::open_restricted. Devices that do not have the
/// minimum capabilities to be recognized as pointer, keyboard or touch
/// device are ignored. Such devices and those that failed to open
/// ignored until the next call to libinput_resume().
///
/// This function may only be called once per context.
///
/// @param libinput A libinput context initialized with
/// libinput_udev_create_context()
/// @param seat_id A seat identifier. This string must not be NULL.
///
/// @return 0 on success or -1 on failure. 
 
 pub fn libinput_udev_assign_seat ( libinput : * mut libinput , seat_id : * const ::libc :: c_char , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup base
///
/// Create a new libinput context that requires the caller to manually add or
/// remove devices with libinput_path_add_device() and
/// libinput_path_remove_device().
///
/// The context is fully initialized but will not generate events until at
/// least one device has been added.
///
/// The reference count of the context is initialized to 1. See @ref
/// libinput_unref.
///
/// @param interface The callback interface
/// @param user_data Caller-specific data passed to the various callback
/// interfaces.
///
/// @return An initialized, empty libinput context. 
 
 pub fn libinput_path_create_context ( interface : * const libinput_interface , user_data : * mut ::libc :: c_void , ) -> * mut libinput ; 
} extern "C" {
 
 /// @ingroup base
///
/// Add a device to a libinput context initialized with
/// libinput_path_create_context(). If successful, the device will be
/// added to the internal list and re-opened on libinput_resume(). The device
/// can be removed with libinput_path_remove_device().
///
/// If the device was successfully initialized, it is returned in the device
/// argument. The lifetime of the returned device pointer is limited until
/// the next libinput_dispatch(), use libinput_device_ref() to keep a permanent
/// reference.
///
/// @param libinput A previously initialized libinput context
/// @param path Path to an input device
/// @return The newly initiated device on success, or NULL on failure.
///
/// @note It is an application bug to call this function on a libinput
/// context initialized with libinput_udev_create_context(). 
 
 pub fn libinput_path_add_device ( libinput : * mut libinput , path : * const ::libc :: c_char , ) -> * mut libinput_device ; 
} extern "C" {
 
 /// @ingroup base
///
/// Remove a device from a libinput context initialized with
/// libinput_path_create_context() or added to such a context with
/// libinput_path_add_device().
///
/// Events already processed from this input device are kept in the queue,
/// the @ref LIBINPUT_EVENT_DEVICE_REMOVED event marks the end of events for
/// this device.
///
/// If no matching device exists, this function does nothing.
///
/// @param device A libinput device
///
/// @note It is an application bug to call this function on a libinput
/// context initialized with libinput_udev_create_context(). 
 
 pub fn libinput_path_remove_device ( device : * mut libinput_device , ) ; 
} extern "C" {
 
 /// @ingroup base
///
/// libinput keeps a single file descriptor for all events. Call into
/// libinput_dispatch() if any events become available on this fd.
///
/// @return The file descriptor used to notify of pending events. 
 
 pub fn libinput_get_fd ( libinput : * mut libinput , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup base
///
/// Main event dispatchment function. Reads events of the file descriptors
/// and processes them internally. Use libinput_get_event() to retrieve the
/// events.
///
/// Dispatching does not necessarily queue libinput events. This function
/// should be called immediately once data is available on the file
/// descriptor returned by libinput_get_fd(). libinput has a number of
/// timing-sensitive features (e.g. tap-to-click), any delay in calling
/// libinput_dispatch() may prevent these features from working correctly.
///
/// @param libinput A previously initialized libinput context
///
/// @return 0 on success, or a negative errno on failure 
 
 pub fn libinput_dispatch ( libinput : * mut libinput , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup base
///
/// Retrieve the next event from libinput's internal event queue.
///
/// After handling the retrieved event, the caller must destroy it using
/// libinput_event_destroy().
///
/// @param libinput A previously initialized libinput context
/// @return The next available event, or NULL if no event is available. 
 
 pub fn libinput_get_event ( libinput : * mut libinput , ) -> * mut libinput_event ; 
} extern "C" {
 
 /// @ingroup base
///
/// Return the type of the next event in the internal queue. This function
/// does not pop the event off the queue and the next call to
/// libinput_get_event() returns that event.
///
/// @param libinput A previously initialized libinput context
/// @return The event type of the next available event or @ref
/// LIBINPUT_EVENT_NONE if no event is available. 
 
 pub fn libinput_next_event_type ( libinput : * mut libinput , ) -> libinput_event_type ; 
} extern "C" {
 
 /// @ingroup base
///
/// Set caller-specific data associated with this context. libinput does
/// not manage, look at, or modify this data. The caller must ensure the
/// data is valid.
///
/// @param libinput A previously initialized libinput context
/// @param user_data Caller-specific data passed to the various callback
/// interfaces. 
 
 pub fn libinput_set_user_data ( libinput : * mut libinput , user_data : * mut ::libc :: c_void , ) ; 
} extern "C" {
 
 /// @ingroup base
///
/// Get the caller-specific data associated with this context, if any.
///
/// @param libinput A previously initialized libinput context
/// @return The caller-specific data previously assigned in
/// libinput_create_udev(). 
 
 pub fn libinput_get_user_data ( libinput : * mut libinput , ) -> * mut ::libc :: c_void ; 
} extern "C" {
 
 /// @ingroup base
///
/// Resume a suspended libinput context. This re-enables device
/// monitoring and adds existing devices.
///
/// @param libinput A previously initialized libinput context
/// @see libinput_suspend
///
/// @return 0 on success or -1 on failure 
 
 pub fn libinput_resume ( libinput : * mut libinput , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup base
///
/// Suspend monitoring for new devices and close existing devices.
/// This all but terminates libinput but does keep the context
/// valid to be resumed with libinput_resume().
///
/// @param libinput A previously initialized libinput context 
 
 pub fn libinput_suspend ( libinput : * mut libinput , ) ; 
} extern "C" {
 
 /// @ingroup base
///
/// Add a reference to the context. A context is destroyed whenever the
/// reference count reaches 0. See @ref libinput_unref.
///
/// @param libinput A previously initialized valid libinput context
/// @return The passed libinput context 
 
 pub fn libinput_ref ( libinput : * mut libinput , ) -> * mut libinput ; 
} extern "C" {
 
 /// @ingroup base
///
/// Dereference the libinput context. After this, the context may have been
/// destroyed, if the last reference was dereferenced. If so, the context is
/// invalid and may not be interacted with.
///
/// @bug When the refcount reaches zero, libinput_unref() releases resources
/// even if a caller still holds refcounted references to related resources
/// (e.g. a libinput_device). When libinput_unref() returns
/// NULL, the caller must consider any resources related to that context
/// invalid. See https://bugs.freedesktop.org/show_bug.cgi?id=91872.
///
/// Example code:
/// @code
/// li = libinput_path_create_context(&interface, NULL);
/// device = libinput_path_add_device(li, "/dev/input/event0");
/// // get extra reference to device
/// libinput_device_ref(device);
///
/// // refcount reaches 0, so *all* resources are cleaned up,
/// // including device
/// libinput_unref(li);
///
/// // INCORRECT: device has been cleaned up and must not be used
/// // li = libinput_device_get_context(device);
/// @endcode
///
/// @param libinput A previously initialized libinput context
/// @return NULL if context was destroyed otherwise the passed context 
 
 pub fn libinput_unref ( libinput : * mut libinput , ) -> * mut libinput ; 
} extern "C" {
 
 /// @ingroup base
///
/// Set the log priority for the libinput context. Messages with priorities
/// equal to or higher than the argument will be printed to the context's
/// log handler.
///
/// The default log priority is @ref LIBINPUT_LOG_PRIORITY_ERROR.
///
/// @param libinput A previously initialized libinput context
/// @param priority The minimum priority of log messages to print.
///
/// @see libinput_log_set_handler
/// @see libinput_log_get_priority 
 
 pub fn libinput_log_set_priority ( libinput : * mut libinput , priority : libinput_log_priority , ) ; 
} extern "C" {
 
 /// @ingroup base
///
/// Get the context's log priority. Messages with priorities equal to or
/// higher than the argument will be printed to the current log handler.
///
/// The default log priority is @ref LIBINPUT_LOG_PRIORITY_ERROR.
///
/// @param libinput A previously initialized libinput context
/// @return The minimum priority of log messages to print.
///
/// @see libinput_log_set_handler
/// @see libinput_log_set_priority 
 
 pub fn libinput_log_get_priority ( libinput : * const libinput , ) -> libinput_log_priority ; 
} 
 /// @ingroup base
///
/// Log handler type for custom logging.
///
/// @param libinput The libinput context
/// @param priority The priority of the current message
/// @param format Message format in printf-style
/// @param args Message arguments
///
/// @see libinput_log_set_priority
/// @see libinput_log_get_priority
/// @see libinput_log_set_handler 
 pub type libinput_log_handler = :: std :: option :: Option < unsafe extern "C" fn ( libinput : * mut libinput , priority : libinput_log_priority , format : * const ::libc :: c_char , args : * mut __va_list_tag ) > ; extern "C" {
 
 /// @ingroup base
///
/// Set the context's log handler. Messages with priorities equal to or
/// higher than the context's log priority will be passed to the given
/// log handler.
///
/// The default log handler prints to stderr.
///
/// @param libinput A previously initialized libinput context
/// @param log_handler The log handler for library messages.
///
/// @see libinput_log_set_priority
/// @see libinput_log_get_priority 
 
 pub fn libinput_log_set_handler ( libinput : * mut libinput , log_handler : libinput_log_handler , ) ; 
} extern "C" {
 
 /// @ingroup seat
///
/// Increase the refcount of the seat. A seat will be freed whenever the
/// refcount reaches 0. This may happen during libinput_dispatch() if the
/// seat was removed from the system. A caller must ensure to reference
/// the seat correctly to avoid dangling pointers.
///
/// @param seat A previously obtained seat
/// @return The passed seat 
 
 pub fn libinput_seat_ref ( seat : * mut libinput_seat , ) -> * mut libinput_seat ; 
} extern "C" {
 
 /// @ingroup seat
///
/// Decrease the refcount of the seat. A seat will be freed whenever the
/// refcount reaches 0. This may happen during libinput_dispatch() if the
/// seat was removed from the system. A caller must ensure to reference
/// the seat correctly to avoid dangling pointers.
///
/// @param seat A previously obtained seat
/// @return NULL if seat was destroyed, otherwise the passed seat 
 
 pub fn libinput_seat_unref ( seat : * mut libinput_seat , ) -> * mut libinput_seat ; 
} extern "C" {
 
 /// @ingroup seat
///
/// Set caller-specific data associated with this seat. libinput does
/// not manage, look at, or modify this data. The caller must ensure the
/// data is valid.
///
/// @param seat A previously obtained seat
/// @param user_data Caller-specific data pointer
/// @see libinput_seat_get_user_data 
 
 pub fn libinput_seat_set_user_data ( seat : * mut libinput_seat , user_data : * mut ::libc :: c_void , ) ; 
} extern "C" {
 
 /// @ingroup seat
///
/// Get the caller-specific data associated with this seat, if any.
///
/// @param seat A previously obtained seat
/// @return Caller-specific data pointer or NULL if none was set
/// @see libinput_seat_set_user_data 
 
 pub fn libinput_seat_get_user_data ( seat : * mut libinput_seat , ) -> * mut ::libc :: c_void ; 
} extern "C" {
 
 /// @ingroup seat
///
/// Get the libinput context from the seat.
///
/// @param seat A previously obtained seat
/// @return The libinput context for this seat. 
 
 pub fn libinput_seat_get_context ( seat : * mut libinput_seat , ) -> * mut libinput ; 
} extern "C" {
 
 /// @ingroup seat
///
/// Return the physical name of the seat. For libinput contexts created from
/// udev, this is always the same value as passed into
/// libinput_udev_assign_seat() and all seats from that context will have
/// the same physical name.
///
/// The physical name of the seat is one that is usually set by the system or
/// lower levels of the stack. In most cases, this is the base filter for
/// devices - devices assigned to seats outside the current seat will not
/// be available to the caller.
///
/// @param seat A previously obtained seat
/// @return The physical name of this seat 
 
 pub fn libinput_seat_get_physical_name ( seat : * mut libinput_seat , ) -> * const ::libc :: c_char ; 
} extern "C" {
 
 /// @ingroup seat
///
/// Return the logical name of the seat. This is an identifier to group sets
/// of devices within the compositor.
///
/// @param seat A previously obtained seat
/// @return The logical name of this seat 
 
 pub fn libinput_seat_get_logical_name ( seat : * mut libinput_seat , ) -> * const ::libc :: c_char ; 
} extern "C" {
 
 /// @ingroup device
///
/// Increase the refcount of the input device. An input device will be freed
/// whenever the refcount reaches 0. This may happen during
/// libinput_dispatch() if the device was removed from the system. A caller
/// must ensure to reference the device correctly to avoid dangling pointers.
///
/// @param device A previously obtained device
/// @return The passed device 
 
 pub fn libinput_device_ref ( device : * mut libinput_device , ) -> * mut libinput_device ; 
} extern "C" {
 
 /// @ingroup device
///
/// Decrease the refcount of the input device. An input device will be freed
/// whenever the refcount reaches 0. This may happen during libinput_dispatch
/// if the device was removed from the system. A caller must ensure to
/// reference the device correctly to avoid dangling pointers.
///
/// @param device A previously obtained device
/// @return NULL if the device was destroyed, otherwise the passed device 
 
 pub fn libinput_device_unref ( device : * mut libinput_device , ) -> * mut libinput_device ; 
} extern "C" {
 
 /// @ingroup device
///
/// Set caller-specific data associated with this input device. libinput does
/// not manage, look at, or modify this data. The caller must ensure the
/// data is valid.
///
/// @param device A previously obtained device
/// @param user_data Caller-specific data pointer
/// @see libinput_device_get_user_data 
 
 pub fn libinput_device_set_user_data ( device : * mut libinput_device , user_data : * mut ::libc :: c_void , ) ; 
} extern "C" {
 
 /// @ingroup device
///
/// Get the caller-specific data associated with this input device, if any.
///
/// @param device A previously obtained device
/// @return Caller-specific data pointer or NULL if none was set
/// @see libinput_device_set_user_data 
 
 pub fn libinput_device_get_user_data ( device : * mut libinput_device , ) -> * mut ::libc :: c_void ; 
} extern "C" {
 
 /// @ingroup device
///
/// Get the libinput context from the device.
///
/// @param device A previously obtained device
/// @return The libinput context for this device. 
 
 pub fn libinput_device_get_context ( device : * mut libinput_device , ) -> * mut libinput ; 
} extern "C" {
 
 /// @ingroup device
///
/// Get the device group this device is assigned to. Some physical
/// devices like graphics tablets are represented by multiple kernel
/// devices and thus by multiple struct @ref libinput_device.
///
/// libinput assigns these devices to the same @ref libinput_device_group
/// allowing the caller to identify such devices and adjust configuration
/// settings accordingly. For example, setting a tablet to left-handed often
/// means turning it upside down. A touch device on the same tablet would
/// need to be turned upside down too to work correctly.
///
/// All devices are part of a device group though for most devices the group
/// will be a singleton. A device is assigned to a device group on @ref
/// LIBINPUT_EVENT_DEVICE_ADDED and removed from that group on @ref
/// LIBINPUT_EVENT_DEVICE_REMOVED. It is up to the caller to track how many
/// devices are in each device group.
///
/// @dot
/// digraph groups_libinput {
/// rankdir="TB";
/// node [
/// shape="box";
/// ]
///
/// mouse [ label="mouse"; URL="\ref libinput_device"];
/// kbd [ label="keyboard"; URL="\ref libinput_device"];
///
/// pen [ label="tablet pen"; URL="\ref libinput_device"];
/// touch [ label="tablet touch"; URL="\ref libinput_device"];
/// pad [ label="tablet pad"; URL="\ref libinput_device"];
///
/// group1 [ label="group 1"; URL="\ref libinput_device_group"];
/// group2 [ label="group 2"; URL="\ref libinput_device_group"];
/// group3 [ label="group 3"; URL="\ref libinput_device_group"];
///
/// mouse -> group1
/// kbd -> group2
///
/// pen -> group3;
/// touch -> group3;
/// pad -> group3;
/// }
/// @enddot
///
/// Device groups do not get re-used once the last device in the group was
/// removed, i.e. unplugging and re-plugging a physical device with grouped
/// devices will return a different device group after every unplug.
///
/// The returned device group is not refcounted and may become invalid after
/// the next call to libinput. Use libinput_device_group_ref() and
/// libinput_device_group_unref() to continue using the handle outside of the
/// immediate scope.
///
/// Device groups are assigned based on the <b>LIBINPUT_DEVICE_GROUP</b> udev
/// property, see @ref udev_config.
///
/// @return The device group this device belongs to 
 
 pub fn libinput_device_get_device_group ( device : * mut libinput_device , ) -> * mut libinput_device_group ; 
} extern "C" {
 
 /// @ingroup device
///
/// Get the system name of the device.
///
/// To get the descriptive device name, use libinput_device_get_name().
///
/// @param device A previously obtained device
/// @return System name of the device
/// 
 
 pub fn libinput_device_get_sysname ( device : * mut libinput_device , ) -> * const ::libc :: c_char ; 
} extern "C" {
 
 /// @ingroup device
///
/// The descriptive device name as advertised by the kernel and/or the
/// hardware itself. To get the sysname for this device, use
/// libinput_device_get_sysname().
///
/// The lifetime of the returned string is tied to the struct
/// libinput_device. The string may be the empty string but is never NULL.
///
/// @param device A previously obtained device
/// @return The device name 
 
 pub fn libinput_device_get_name ( device : * mut libinput_device , ) -> * const ::libc :: c_char ; 
} extern "C" {
 
 /// @ingroup device
///
/// Get the product ID for this device.
///
/// @param device A previously obtained device
/// @return The product ID of this device 
 
 pub fn libinput_device_get_id_product ( device : * mut libinput_device , ) -> ::libc :: c_uint ; 
} extern "C" {
 
 /// @ingroup device
///
/// Get the vendor ID for this device.
///
/// @param device A previously obtained device
/// @return The vendor ID of this device 
 
 pub fn libinput_device_get_id_vendor ( device : * mut libinput_device , ) -> ::libc :: c_uint ; 
} extern "C" {
 
 /// @ingroup device
///
/// A device may be mapped to a single output, or all available outputs. If a
/// device is mapped to a single output only, a relative device may not move
/// beyond the boundaries of this output. An absolute device has its input
/// coordinates mapped to the extents of this output.
///
/// @note <b>Use of this function is discouraged.</b> Its return value is not
/// precisely defined and may not be understood by the caller or may be
/// insufficient to map the device. Instead, the system configuration could
/// set a udev property the caller understands and interprets correctly. The
/// caller could then obtain device with libinput_device_get_udev_device()
/// and query it for this property. For more complex cases, the caller
/// must implement monitor-to-device association heuristics.
///
/// @return The name of the output this device is mapped to, or NULL if no
/// output is set 
 
 pub fn libinput_device_get_output_name ( device : * mut libinput_device , ) -> * const ::libc :: c_char ; 
} extern "C" {
 
 /// @ingroup device
///
/// Get the seat associated with this input device, see @ref seats for
/// details.
///
/// A seat can be uniquely identified by the physical and logical seat name.
/// There will ever be only one seat instance with a given physical and logical
/// seat name pair at any given time, but if no external reference is kept, it
/// may be destroyed if no device belonging to it is left.
///
/// The returned seat is not refcounted and may become invalid after
/// the next call to libinput. Use libinput_seat_ref() and
/// libinput_seat_unref() to continue using the handle outside of the
/// immediate scope.
///
/// @param device A previously obtained device
/// @return The seat this input device belongs to 
 
 pub fn libinput_device_get_seat ( device : * mut libinput_device , ) -> * mut libinput_seat ; 
} extern "C" {
 
 /// @ingroup device
///
/// Change the logical seat associated with this device by removing the
/// device and adding it to the new seat.
///
/// This command is identical to physically unplugging the device, then
/// re-plugging it as a member of the new seat. libinput will generate a
/// @ref LIBINPUT_EVENT_DEVICE_REMOVED event and this @ref libinput_device is
/// considered removed from the context; it will not generate further events
/// and will be freed when the refcount reaches zero.
/// A @ref LIBINPUT_EVENT_DEVICE_ADDED event is generated with a new @ref
/// libinput_device handle. It is the caller's responsibility to update
/// references to the new device accordingly.
///
/// If the logical seat name already exists in the device's physical seat,
/// the device is added to this seat. Otherwise, a new seat is created.
///
/// @note This change applies to this device until removal or @ref
/// libinput_suspend(), whichever happens earlier.
///
/// @param device A previously obtained device
/// @param name The new logical seat name
/// @return 0 on success, non-zero on error 
 
 pub fn libinput_device_set_seat_logical_name ( device : * mut libinput_device , name : * const ::libc :: c_char , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup device
///
/// Return a udev handle to the device that is this libinput device, if any.
/// The returned handle has a refcount of at least 1, the caller must call
/// <i>udev_device_unref()</i> once to release the associated resources.
/// See the [libudev documentation]
/// (http://www.freedesktop.org/software/systemd/libudev/) for details.
///
/// Some devices may not have a udev device, or the udev device may be
/// unobtainable. This function returns NULL if no udev device was available.
///
/// Calling this function multiple times for the same device may not
/// return the same udev handle each time.
///
/// @param device A previously obtained device
/// @return A udev handle to the device with a refcount of >= 1 or NULL.
/// @retval NULL This device is not represented by a udev device 
 
 pub fn libinput_device_get_udev_device ( device : * mut libinput_device , ) -> * mut udev_device ; 
} extern "C" {
 
 /// @ingroup device
///
/// Update the LEDs on the device, if any. If the device does not have
/// LEDs, or does not have one or more of the LEDs given in the mask, this
/// function does nothing.
///
/// @param device A previously obtained device
/// @param leds A mask of the LEDs to set, or unset. 
 
 pub fn libinput_device_led_update ( device : * mut libinput_device , leds : libinput_led , ) ; 
} extern "C" {
 
 /// @ingroup device
///
/// Check if the given device has the specified capability
///
/// @return Non-zero if the given device has the capability or zero otherwise 
 
 pub fn libinput_device_has_capability ( device : * mut libinput_device , capability : libinput_device_capability , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup device
///
/// Get the physical size of a device in mm, where meaningful. This function
/// only succeeds on devices with the required data, i.e. tablets, touchpads
/// and touchscreens.
///
/// If this function returns nonzero, width and height are unmodified.
///
/// @param device The device
/// @param width Set to the width of the device
/// @param height Set to the height of the device
/// @return 0 on success, or nonzero otherwise 
 
 pub fn libinput_device_get_size ( device : * mut libinput_device , width : * mut f64 , height : * mut f64 , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup device
///
/// Check if a @ref LIBINPUT_DEVICE_CAP_POINTER device has a button with the
/// given code (see linux/input.h).
///
/// @param device A current input device
/// @param code Button code to check for, e.g. <i>BTN_LEFT</i>
///
/// @return 1 if the device supports this button code, 0 if it does not, -1
/// on error. 
 
 pub fn libinput_device_pointer_has_button ( device : * mut libinput_device , code : u32 , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup device
///
/// Check if a @ref LIBINPUT_DEVICE_CAP_KEYBOARD device has a key with the
/// given code (see linux/input.h).
///
/// @param device A current input device
/// @param code Key code to check for, e.g. <i>KEY_ESC</i>
///
/// @return 1 if the device supports this key code, 0 if it does not, -1
/// on error. 
 
 pub fn libinput_device_keyboard_has_key ( device : * mut libinput_device , code : u32 , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup device
///
/// Check how many touches a @ref LIBINPUT_DEVICE_CAP_TOUCH device supports
/// simultaneously.
///
/// @param device A current input device
///
/// @return The number of simultaneous touches or 0 if unknown, -1
/// on error. 
 
 pub fn libinput_device_touch_get_touch_count ( device : * mut libinput_device , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup device
///
/// Check if a @ref LIBINPUT_DEVICE_CAP_SWITCH device has a switch of the
/// given type.
///
/// @param device A current input device
/// @param sw Switch to check for
///
/// @return 1 if the device supports this switch, 0 if it does not, -1
/// on error. 
 
 pub fn libinput_device_switch_has_switch ( device : * mut libinput_device , sw : libinput_switch , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup device
///
/// Return the number of buttons on a device with the
/// @ref LIBINPUT_DEVICE_CAP_TABLET_PAD capability.
/// Buttons on a pad device are numbered sequentially, see @ref
/// tablet-pad-buttons for details.
///
/// @param device A current input device
///
/// @return The number of buttons supported by the device. 
 
 pub fn libinput_device_tablet_pad_get_num_buttons ( device : * mut libinput_device , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup device
///
/// Return the number of rings a device with the @ref
/// LIBINPUT_DEVICE_CAP_TABLET_PAD capability provides.
///
/// @param device A current input device
///
/// @return The number of rings or 0 if the device has no rings.
///
/// @see libinput_event_tablet_pad_get_ring_number 
 
 pub fn libinput_device_tablet_pad_get_num_rings ( device : * mut libinput_device , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup device
///
/// Return the number of strips a device with the @ref
/// LIBINPUT_DEVICE_CAP_TABLET_PAD capability provides.
///
/// @param device A current input device
///
/// @return The number of strips or 0 if the device has no strips.
///
/// @see libinput_event_tablet_pad_get_strip_number 
 
 pub fn libinput_device_tablet_pad_get_num_strips ( device : * mut libinput_device , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup device
///
/// Increase the refcount of the device group. A device group will be freed
/// whenever the refcount reaches 0. This may happen during
/// libinput_dispatch() if all devices of this group were removed from the
/// system. A caller must ensure to reference the device group correctly to
/// avoid dangling pointers.
///
/// @param group A previously obtained device group
/// @return The passed device group 
 
 pub fn libinput_device_group_ref ( group : * mut libinput_device_group , ) -> * mut libinput_device_group ; 
} extern "C" {
 
 /// @ingroup device
///
/// Decrease the refcount of the device group. A device group will be freed
/// whenever the refcount reaches 0. This may happen during
/// libinput_dispatch() if all devices of this group were removed from the
/// system. A caller must ensure to reference the device group correctly to
/// avoid dangling pointers.
///
/// @param group A previously obtained device group
/// @return NULL if the device group was destroyed, otherwise the passed
/// device group 
 
 pub fn libinput_device_group_unref ( group : * mut libinput_device_group , ) -> * mut libinput_device_group ; 
} extern "C" {
 
 /// @ingroup device
///
/// Set caller-specific data associated with this device group. libinput does
/// not manage, look at, or modify this data. The caller must ensure the
/// data is valid.
///
/// @param group A previously obtained device group
/// @param user_data Caller-specific data pointer
/// @see libinput_device_group_get_user_data 
 
 pub fn libinput_device_group_set_user_data ( group : * mut libinput_device_group , user_data : * mut ::libc :: c_void , ) ; 
} extern "C" {
 
 /// @ingroup device
///
/// Get the caller-specific data associated with this input device group, if
/// any.
///
/// @param group A previously obtained group
/// @return Caller-specific data pointer or NULL if none was set
/// @see libinput_device_group_set_user_data 
 
 pub fn libinput_device_group_get_user_data ( group : * mut libinput_device_group , ) -> * mut ::libc :: c_void ; 
} pub const libinput_config_status_LIBINPUT_CONFIG_STATUS_SUCCESS : libinput_config_status = 0 ; pub const libinput_config_status_LIBINPUT_CONFIG_STATUS_UNSUPPORTED : libinput_config_status = 1 ; pub const libinput_config_status_LIBINPUT_CONFIG_STATUS_INVALID : libinput_config_status = 2 ; pub type libinput_config_status = ::libc :: c_uint ; extern "C" {
 
 /// @ingroup config
///
/// Return a string describing the error.
///
/// @param status The status to translate to a string
/// @return A human-readable string representing the error or NULL for an
/// invalid status. 
 
 pub fn libinput_config_status_to_str ( status : libinput_config_status , ) -> * const ::libc :: c_char ; 
} pub const libinput_config_tap_state_LIBINPUT_CONFIG_TAP_DISABLED : libinput_config_tap_state = 0 ; pub const libinput_config_tap_state_LIBINPUT_CONFIG_TAP_ENABLED : libinput_config_tap_state = 1 ; pub type libinput_config_tap_state = ::libc :: c_uint ; extern "C" {
 
 /// @ingroup config
///
/// Check if the device supports tap-to-click and how many fingers can be
/// used for tapping. See
/// libinput_device_config_tap_set_enabled() for more information.
///
/// @param device The device to configure
/// @return The number of fingers that can generate a tap event, or 0 if the
/// device does not support tapping.
///
/// @see libinput_device_config_tap_set_enabled
/// @see libinput_device_config_tap_get_enabled
/// @see libinput_device_config_tap_get_default_enabled 
 
 pub fn libinput_device_config_tap_get_finger_count ( device : * mut libinput_device , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup config
///
/// Enable or disable tap-to-click on this device, with a default mapping of
/// 1, 2, 3 finger tap mapping to left, right, middle click, respectively.
/// Tapping is limited by the number of simultaneous touches
/// supported by the device, see
/// libinput_device_config_tap_get_finger_count().
///
/// @param device The device to configure
/// @param enable @ref LIBINPUT_CONFIG_TAP_ENABLED to enable tapping or @ref
/// LIBINPUT_CONFIG_TAP_DISABLED to disable tapping
///
/// @return A config status code. Disabling tapping on a device that does not
/// support tapping always succeeds.
///
/// @see libinput_device_config_tap_get_finger_count
/// @see libinput_device_config_tap_get_enabled
/// @see libinput_device_config_tap_get_default_enabled 
 
 pub fn libinput_device_config_tap_set_enabled ( device : * mut libinput_device , enable : libinput_config_tap_state , ) -> libinput_config_status ; 
} extern "C" {
 
 /// @ingroup config
///
/// Check if tap-to-click is enabled on this device. If the device does not
/// support tapping, this function always returns @ref
/// LIBINPUT_CONFIG_TAP_DISABLED.
///
/// @param device The device to configure
///
/// @retval LIBINPUT_CONFIG_TAP_ENABLED If tapping is currently enabled
/// @retval LIBINPUT_CONFIG_TAP_DISABLED If tapping is currently disabled
///
/// @see libinput_device_config_tap_get_finger_count
/// @see libinput_device_config_tap_set_enabled
/// @see libinput_device_config_tap_get_default_enabled 
 
 pub fn libinput_device_config_tap_get_enabled ( device : * mut libinput_device , ) -> libinput_config_tap_state ; 
} extern "C" {
 
 /// @ingroup config
///
/// Return the default setting for whether tap-to-click is enabled on this
/// device.
///
/// @param device The device to configure
/// @retval LIBINPUT_CONFIG_TAP_ENABLED If tapping is enabled by default
/// @retval LIBINPUT_CONFIG_TAP_DISABLED If tapping Is disabled by default
///
/// @see libinput_device_config_tap_get_finger_count
/// @see libinput_device_config_tap_set_enabled
/// @see libinput_device_config_tap_get_enabled 
 
 pub fn libinput_device_config_tap_get_default_enabled ( device : * mut libinput_device , ) -> libinput_config_tap_state ; 
} pub const libinput_config_tap_button_map_LIBINPUT_CONFIG_TAP_MAP_LRM : libinput_config_tap_button_map = 0 ; pub const libinput_config_tap_button_map_LIBINPUT_CONFIG_TAP_MAP_LMR : libinput_config_tap_button_map = 1 ; pub type libinput_config_tap_button_map = ::libc :: c_uint ; extern "C" {
 
 /// @ingroup config
///
/// Set the finger number to button number mapping for tap-to-click. The
/// default mapping on most devices is to have a 1, 2 and 3 finger tap to map
/// to the left, right and middle button, respectively.
/// A device may permit changing the button mapping but disallow specific
/// maps. In this case @ref LIBINPUT_CONFIG_STATUS_UNSUPPORTED is returned,
/// the caller is expected to handle this case correctly.
///
/// Changing the button mapping may not take effect immediately,
/// the device may wait until it is in a neutral state before applying any
/// changes.
///
/// The mapping may be changed when tap-to-click is disabled. The new mapping
/// takes effect when tap-to-click is enabled in the future.
///
/// @note It is an application bug to call this function for devices where
/// libinput_device_config_tap_get_finger_count() returns 0.
///
/// @param device The device to configure
/// @param map The new finger-to-button number mapping
/// @return A config status code. Changing the order on a device that does not
/// support tapping always fails with @ref LIBINPUT_CONFIG_STATUS_UNSUPPORTED.
///
/// @see libinput_device_config_tap_get_button_map
/// @see libinput_device_config_tap_get_default_button_map 
 
 pub fn libinput_device_config_tap_set_button_map ( device : * mut libinput_device , map : libinput_config_tap_button_map , ) -> libinput_config_status ; 
} extern "C" {
 
 /// @ingroup config
///
/// Get the finger number to button number mapping for tap-to-click.
///
/// The return value for a device that does not support tapping is always
/// @ref LIBINPUT_CONFIG_TAP_MAP_LRM.
///
/// @note It is an application bug to call this function for devices where
/// libinput_device_config_tap_get_finger_count() returns 0.
///
/// @param device The device to configure
/// @return The current finger-to-button number mapping
///
/// @see libinput_device_config_tap_set_button_map
/// @see libinput_device_config_tap_get_default_button_map 
 
 pub fn libinput_device_config_tap_get_button_map ( device : * mut libinput_device , ) -> libinput_config_tap_button_map ; 
} extern "C" {
 
 /// @ingroup config
///
/// Get the default finger number to button number mapping for tap-to-click.
///
/// The return value for a device that does not support tapping is always
/// @ref LIBINPUT_CONFIG_TAP_MAP_LRM.
///
/// @note It is an application bug to call this function for devices where
/// libinput_device_config_tap_get_finger_count() returns 0.
///
/// @param device The device to configure
/// @return The current finger-to-button number mapping
///
/// @see libinput_device_config_tap_set_button_map
/// @see libinput_device_config_tap_get_default_button_map 
 
 pub fn libinput_device_config_tap_get_default_button_map ( device : * mut libinput_device , ) -> libinput_config_tap_button_map ; 
} pub const libinput_config_drag_state_LIBINPUT_CONFIG_DRAG_DISABLED : libinput_config_drag_state = 0 ; pub const libinput_config_drag_state_LIBINPUT_CONFIG_DRAG_ENABLED : libinput_config_drag_state = 1 ; pub type libinput_config_drag_state = ::libc :: c_uint ; extern "C" {
 
 /// @ingroup config
///
/// Enable or disable tap-and-drag on this device. When enabled, a
/// single-finger tap immediately followed by a finger down results in a
/// button down event, subsequent finger motion thus triggers a drag. The
/// button is released on finger up. See @ref tapndrag for more details.
///
/// @param device The device to configure
/// @param enable @ref LIBINPUT_CONFIG_DRAG_ENABLED to enable, @ref
/// LIBINPUT_CONFIG_DRAG_DISABLED to disable tap-and-drag
///
/// @see libinput_device_config_tap_drag_get_enabled
/// @see libinput_device_config_tap_drag_get_default_enabled 
 
 pub fn libinput_device_config_tap_set_drag_enabled ( device : * mut libinput_device , enable : libinput_config_drag_state , ) -> libinput_config_status ; 
} extern "C" {
 
 /// @ingroup config
///
/// Return whether tap-and-drag is enabled or disabled on this device.
///
/// @param device The device to check
/// @retval LIBINPUT_CONFIG_DRAG_ENABLED if tap-and-drag is enabled
/// @retval LIBINPUT_CONFIG_DRAG_DISABLED if tap-and-drag is
/// disabled
///
/// @see libinput_device_config_tap_drag_set_enabled
/// @see libinput_device_config_tap_drag_get_default_enabled 
 
 pub fn libinput_device_config_tap_get_drag_enabled ( device : * mut libinput_device , ) -> libinput_config_drag_state ; 
} extern "C" {
 
 /// @ingroup config
///
/// Return whether tap-and-drag is enabled or disabled by default on this
/// device.
///
/// @param device The device to check
/// @retval LIBINPUT_CONFIG_DRAG_ENABLED if tap-and-drag is enabled by
/// default
/// @retval LIBINPUT_CONFIG_DRAG_DISABLED if tap-and-drag is
/// disabled by default
///
/// @see libinput_device_config_tap_drag_set_enabled
/// @see libinput_device_config_tap_drag_get_enabled 
 
 pub fn libinput_device_config_tap_get_default_drag_enabled ( device : * mut libinput_device , ) -> libinput_config_drag_state ; 
} pub const libinput_config_drag_lock_state_LIBINPUT_CONFIG_DRAG_LOCK_DISABLED : libinput_config_drag_lock_state = 0 ; pub const libinput_config_drag_lock_state_LIBINPUT_CONFIG_DRAG_LOCK_ENABLED : libinput_config_drag_lock_state = 1 ; pub type libinput_config_drag_lock_state = ::libc :: c_uint ; extern "C" {
 
 /// @ingroup config
///
/// Enable or disable drag-lock during tapping on this device. When enabled,
/// a finger may be lifted and put back on the touchpad within a timeout and
/// the drag process continues. When disabled, lifting the finger during a
/// tap-and-drag will immediately stop the drag. See @ref tapndrag for
/// details.
///
/// Enabling drag lock on a device that has tapping disabled is permitted,
/// but has no effect until tapping is enabled.
///
/// @param device The device to configure
/// @param enable @ref LIBINPUT_CONFIG_DRAG_LOCK_ENABLED to enable drag lock
/// or @ref LIBINPUT_CONFIG_DRAG_LOCK_DISABLED to disable drag lock
///
/// @return A config status code. Disabling drag lock on a device that does not
/// support tapping always succeeds.
///
/// @see libinput_device_config_tap_get_drag_lock_enabled
/// @see libinput_device_config_tap_get_default_drag_lock_enabled 
 
 pub fn libinput_device_config_tap_set_drag_lock_enabled ( device : * mut libinput_device , enable : libinput_config_drag_lock_state , ) -> libinput_config_status ; 
} extern "C" {
 
 /// @ingroup config
///
/// Check if drag-lock during tapping is enabled on this device. If the
/// device does not support tapping, this function always returns
/// @ref LIBINPUT_CONFIG_DRAG_LOCK_DISABLED.
///
/// Drag lock may be enabled even when tapping is disabled.
///
/// @param device The device to configure
///
/// @retval LIBINPUT_CONFIG_DRAG_LOCK_ENABLED If drag lock is currently enabled
/// @retval LIBINPUT_CONFIG_DRAG_LOCK_DISABLED If drag lock is currently disabled
///
/// @see libinput_device_config_tap_set_drag_lock_enabled
/// @see libinput_device_config_tap_get_default_drag_lock_enabled 
 
 pub fn libinput_device_config_tap_get_drag_lock_enabled ( device : * mut libinput_device , ) -> libinput_config_drag_lock_state ; 
} extern "C" {
 
 /// @ingroup config
///
/// Check if drag-lock during tapping is enabled by default on this device.
/// If the device does not support tapping, this function always returns
/// @ref LIBINPUT_CONFIG_DRAG_LOCK_DISABLED.
///
/// Drag lock may be enabled by default even when tapping is disabled by
/// default.
///
/// @param device The device to configure
///
/// @retval LIBINPUT_CONFIG_DRAG_LOCK_ENABLED If drag lock is enabled by
/// default
/// @retval LIBINPUT_CONFIG_DRAG_LOCK_DISABLED If drag lock is disabled by
/// default
///
/// @see libinput_device_config_tap_set_drag_lock_enabled
/// @see libinput_device_config_tap_get_drag_lock_enabled 
 
 pub fn libinput_device_config_tap_get_default_drag_lock_enabled ( device : * mut libinput_device , ) -> libinput_config_drag_lock_state ; 
} extern "C" {
 
 /// @ingroup config
///
/// Check if the device can be calibrated via a calibration matrix.
///
/// @param device The device to check
/// @return Non-zero if the device can be calibrated, zero otherwise.
///
/// @see libinput_device_config_calibration_set_matrix
/// @see libinput_device_config_calibration_get_matrix
/// @see libinput_device_config_calibration_get_default_matrix 
 
 pub fn libinput_device_config_calibration_has_matrix ( device : * mut libinput_device , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup config
///
/// Apply the 3x3 transformation matrix to absolute device coordinates. This
/// matrix has no effect on relative events.
///
/// Given a 6-element array [a, b, c, d, e, f], the matrix is applied as
/// @code
/// [ a  b  c ]   [ x ]
/// [ d  e  f ] * [ y ]
/// [ 0  0  1 ]   [ 1 ]
/// @endcode
///
/// The translation component (c, f) is expected to be normalized to the
/// device coordinate range. For example, the matrix
/// @code
/// [ 1 0  1 ]
/// [ 0 1 -1 ]
/// [ 0 0  1 ]
/// @endcode
/// moves all coordinates by 1 device-width to the right and 1 device-height
/// up.
///
/// The rotation matrix for rotation around the origin is defined as
/// @code
/// [ cos(a) -sin(a) 0 ]
/// [ sin(a)  cos(a) 0 ]
/// [   0      0     1 ]
/// @endcode
/// Note that any rotation requires an additional translation component to
/// translate the rotated coordinates back into the original device space.
/// The rotation matrixes for 90, 180 and 270 degrees clockwise are:
/// @code
/// 90 deg cw:		180 deg cw:		270 deg cw:
/// [ 0 -1 1]		[ -1  0 1]		[  0 1 0 ]
/// [ 1  0 0]		[  0 -1 1]		[ -1 0 1 ]
/// [ 0  0 1]		[  0  0 1]		[  0 0 1 ]
/// @endcode
///
/// @param device The device to configure
/// @param matrix An array representing the first two rows of a 3x3 matrix as
/// described above.
///
/// @return A config status code.
///
/// @see libinput_device_config_calibration_has_matrix
/// @see libinput_device_config_calibration_get_matrix
/// @see libinput_device_config_calibration_get_default_matrix 
 
 pub fn libinput_device_config_calibration_set_matrix ( device : * mut libinput_device , matrix : * const f32 , ) -> libinput_config_status ; 
} extern "C" {
 
 /// @ingroup config
///
/// Return the current calibration matrix for this device.
///
/// @param device The device to configure
/// @param matrix Set to the array representing the first two rows of a 3x3 matrix as
/// described in libinput_device_config_calibration_set_matrix().
///
/// @return 0 if no calibration is set and the returned matrix is the
/// identity matrix, 1 otherwise
///
/// @see libinput_device_config_calibration_has_matrix
/// @see libinput_device_config_calibration_set_matrix
/// @see libinput_device_config_calibration_get_default_matrix 
 
 pub fn libinput_device_config_calibration_get_matrix ( device : * mut libinput_device , matrix : * mut f32 , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup config
///
/// Return the default calibration matrix for this device. On most devices,
/// this is the identity matrix. If the udev property
/// <b>LIBINPUT_CALIBRATION_MATRIX</b> is set on the respective udev device,
/// that property's value becomes the default matrix, see @ref udev_config.
///
/// @param device The device to configure
/// @param matrix Set to the array representing the first two rows of a 3x3 matrix as
/// described in libinput_device_config_calibration_set_matrix().
///
/// @return 0 if no calibration is set and the returned matrix is the
/// identity matrix, 1 otherwise
///
/// @see libinput_device_config_calibration_has_matrix
/// @see libinput_device_config_calibration_set_matrix
/// @see libinput_device_config_calibration_get_matrix 
 
 pub fn libinput_device_config_calibration_get_default_matrix ( device : * mut libinput_device , matrix : * mut f32 , ) -> ::libc :: c_int ; 
} pub const libinput_config_send_events_mode_LIBINPUT_CONFIG_SEND_EVENTS_ENABLED : libinput_config_send_events_mode = 0 ; pub const libinput_config_send_events_mode_LIBINPUT_CONFIG_SEND_EVENTS_DISABLED : libinput_config_send_events_mode = 1 ; pub const libinput_config_send_events_mode_LIBINPUT_CONFIG_SEND_EVENTS_DISABLED_ON_EXTERNAL_MOUSE : libinput_config_send_events_mode = 2 ; pub type libinput_config_send_events_mode = ::libc :: c_uint ; extern "C" {
 
 /// @ingroup config
///
/// Return the possible send-event modes for this device. These modes define
/// when a device may process and send events.
///
/// @param device The device to configure
///
/// @return A bitmask of possible modes.
///
/// @see libinput_device_config_send_events_set_mode
/// @see libinput_device_config_send_events_get_mode
/// @see libinput_device_config_send_events_get_default_mode 
 
 pub fn libinput_device_config_send_events_get_modes ( device : * mut libinput_device , ) -> u32 ; 
} extern "C" {
 
 /// @ingroup config
///
/// Set the send-event mode for this device. The mode defines when the device
/// processes and sends events to the caller.
///
/// The selected mode may not take effect immediately. Events already
/// received and processed from this device are unaffected and will be passed
/// to the caller on the next call to libinput_get_event().
///
/// If the mode is a bitmask of @ref libinput_config_send_events_mode,
/// the device may wait for or generate events until it is in a neutral
/// state. For example, this may include waiting for or generating button
/// release events.
///
/// If the device is already suspended, this function does nothing and
/// returns success. Changing the send-event mode on a device that has been
/// removed is permitted.
///
/// @param device The device to configure
/// @param mode A bitmask of send-events modes
///
/// @return A config status code.
///
/// @see libinput_device_config_send_events_get_modes
/// @see libinput_device_config_send_events_get_mode
/// @see libinput_device_config_send_events_get_default_mode 
 
 pub fn libinput_device_config_send_events_set_mode ( device : * mut libinput_device , mode : u32 , ) -> libinput_config_status ; 
} extern "C" {
 
 /// @ingroup config
///
/// Get the send-event mode for this device. The mode defines when the device
/// processes and sends events to the caller.
///
/// If a caller enables the bits for multiple modes, some of which are
/// subsets of another mode libinput may drop the bits that are subsets. In
/// other words, don't expect libinput_device_config_send_events_get_mode()
/// to always return exactly the same bitmask as passed into
/// libinput_device_config_send_events_set_mode().
///
/// @param device The device to configure
/// @return The current bitmask of the send-event mode for this device.
///
/// @see libinput_device_config_send_events_get_modes
/// @see libinput_device_config_send_events_set_mode
/// @see libinput_device_config_send_events_get_default_mode 
 
 pub fn libinput_device_config_send_events_get_mode ( device : * mut libinput_device , ) -> u32 ; 
} extern "C" {
 
 /// @ingroup config
///
/// Get the default send-event mode for this device. The mode defines when
/// the device processes and sends events to the caller.
///
/// @param device The device to configure
/// @return The bitmask of the send-event mode for this device.
///
/// @see libinput_device_config_send_events_get_modes
/// @see libinput_device_config_send_events_set_mode
/// @see libinput_device_config_send_events_get_mode 
 
 pub fn libinput_device_config_send_events_get_default_mode ( device : * mut libinput_device , ) -> u32 ; 
} extern "C" {
 
 /// @ingroup config
///
/// Check if a device uses libinput-internal pointer-acceleration.
///
/// @param device The device to configure
///
/// @return 0 if the device is not accelerated, nonzero if it is accelerated
///
/// @see libinput_device_config_accel_set_speed
/// @see libinput_device_config_accel_get_speed
/// @see libinput_device_config_accel_get_default_speed 
 
 pub fn libinput_device_config_accel_is_available ( device : * mut libinput_device , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup config
///
/// Set the pointer acceleration speed of this pointer device within a range
/// of [-1, 1], where 0 is the default acceleration for this device, -1 is
/// the slowest acceleration and 1 is the maximum acceleration available on
/// this device. The actual pointer acceleration mechanism is
/// implementation-dependent, as is the number of steps available within the
/// range. libinput picks the semantically closest acceleration step if the
/// requested value does not match a discrete setting.
///
/// @param device The device to configure
/// @param speed The normalized speed, in a range of [-1, 1]
///
/// @return A config status code
///
/// @see libinput_device_config_accel_is_available
/// @see libinput_device_config_accel_get_speed
/// @see libinput_device_config_accel_get_default_speed 
 
 pub fn libinput_device_config_accel_set_speed ( device : * mut libinput_device , speed : f64 , ) -> libinput_config_status ; 
} extern "C" {
 
 /// @ingroup config
///
/// Get the current pointer acceleration setting for this pointer device. The
/// returned value is normalized to a range of [-1, 1].
/// See libinput_device_config_accel_set_speed() for details.
///
/// @param device The device to configure
///
/// @return The current speed, range -1 to 1
///
/// @see libinput_device_config_accel_is_available
/// @see libinput_device_config_accel_set_speed
/// @see libinput_device_config_accel_get_default_speed 
 
 pub fn libinput_device_config_accel_get_speed ( device : * mut libinput_device , ) -> f64 ; 
} extern "C" {
 
 /// @ingroup config
///
/// Return the default speed setting for this device, normalized to a range
/// of [-1, 1].
/// See libinput_device_config_accel_set_speed() for details.
///
/// @param device The device to configure
/// @return The default speed setting for this device.
///
/// @see libinput_device_config_accel_is_available
/// @see libinput_device_config_accel_set_speed
/// @see libinput_device_config_accel_get_speed 
 
 pub fn libinput_device_config_accel_get_default_speed ( device : * mut libinput_device , ) -> f64 ; 
} pub const libinput_config_accel_profile_LIBINPUT_CONFIG_ACCEL_PROFILE_NONE : libinput_config_accel_profile = 0 ; pub const libinput_config_accel_profile_LIBINPUT_CONFIG_ACCEL_PROFILE_FLAT : libinput_config_accel_profile = 1 ; pub const libinput_config_accel_profile_LIBINPUT_CONFIG_ACCEL_PROFILE_ADAPTIVE : libinput_config_accel_profile = 2 ; pub type libinput_config_accel_profile = ::libc :: c_uint ; extern "C" {
 
 /// @ingroup config
///
/// Returns a bitmask of the configurable acceleration modes available on
/// this device.
///
/// @param device The device to configure
///
/// @return A bitmask of all configurable modes available on this device. 
 
 pub fn libinput_device_config_accel_get_profiles ( device : * mut libinput_device , ) -> u32 ; 
} extern "C" {
 
 /// @ingroup config
///
/// Set the pointer acceleration profile of this pointer device to the given
/// mode.
///
/// @param device The device to configure
/// @param mode The mode to set the device to.
///
/// @return A config status code 
 
 pub fn libinput_device_config_accel_set_profile ( device : * mut libinput_device , mode : libinput_config_accel_profile , ) -> libinput_config_status ; 
} extern "C" {
 
 /// @ingroup config
///
/// Get the current pointer acceleration profile for this pointer device.
///
/// @param device The device to configure
///
/// @return The currently configured pointer acceleration profile. 
 
 pub fn libinput_device_config_accel_get_profile ( device : * mut libinput_device , ) -> libinput_config_accel_profile ; 
} extern "C" {
 
 /// @ingroup config
///
/// Return the default pointer acceleration profile for this pointer device.
///
/// @param device The device to configure
///
/// @return The default acceleration profile for this device. 
 
 pub fn libinput_device_config_accel_get_default_profile ( device : * mut libinput_device , ) -> libinput_config_accel_profile ; 
} extern "C" {
 
 /// @ingroup config
///
/// Return non-zero if the device supports "natural scrolling".
///
/// In traditional scroll mode, the movement of fingers on a touchpad when
/// scrolling matches the movement of the scroll bars. When the fingers move
/// down, the scroll bar moves down, a line of text on the screen moves
/// towards the upper end of the screen. This also matches scroll wheels on
/// mice (wheel down, content moves up).
///
/// Natural scrolling is the term coined by Apple for inverted scrolling.
/// In this mode, the effect of scrolling movement of fingers on a touchpad
/// resemble physical manipulation of paper. When the fingers move down, a
/// line of text on the screen moves down (scrollbars move up). This is the
/// opposite of scroll wheels on mice.
///
/// A device supporting natural scrolling can be switched between traditional
/// scroll mode and natural scroll mode.
///
/// @param device The device to configure
///
/// @return Zero if natural scrolling is not supported, non-zero if natural
/// scrolling is supported by this device
///
/// @see libinput_device_config_scroll_set_natural_scroll_enabled
/// @see libinput_device_config_scroll_get_natural_scroll_enabled
/// @see libinput_device_config_scroll_get_default_natural_scroll_enabled 
 
 pub fn libinput_device_config_scroll_has_natural_scroll ( device : * mut libinput_device , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup config
///
/// Enable or disable natural scrolling on the device.
///
/// @param device The device to configure
/// @param enable non-zero to enable, zero to disable natural scrolling
///
/// @return A config status code
///
/// @see libinput_device_config_scroll_has_natural_scroll
/// @see libinput_device_config_scroll_get_natural_scroll_enabled
/// @see libinput_device_config_scroll_get_default_natural_scroll_enabled 
 
 pub fn libinput_device_config_scroll_set_natural_scroll_enabled ( device : * mut libinput_device , enable : ::libc :: c_int , ) -> libinput_config_status ; 
} extern "C" {
 
 /// @ingroup config
///
/// Get the current mode for scrolling on this device
///
/// @param device The device to configure
///
/// @return Zero if natural scrolling is disabled, non-zero if enabled
///
/// @see libinput_device_config_scroll_has_natural_scroll
/// @see libinput_device_config_scroll_set_natural_scroll_enabled
/// @see libinput_device_config_scroll_get_default_natural_scroll_enabled 
 
 pub fn libinput_device_config_scroll_get_natural_scroll_enabled ( device : * mut libinput_device , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup config
///
/// Get the default mode for scrolling on this device
///
/// @param device The device to configure
///
/// @return Zero if natural scrolling is disabled by default, non-zero if enabled
///
/// @see libinput_device_config_scroll_has_natural_scroll
/// @see libinput_device_config_scroll_set_natural_scroll_enabled
/// @see libinput_device_config_scroll_get_natural_scroll_enabled 
 
 pub fn libinput_device_config_scroll_get_default_natural_scroll_enabled ( device : * mut libinput_device , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup config
///
/// Check if a device has a configuration that supports left-handed usage.
///
/// @param device The device to configure
/// @return Non-zero if the device can be set to left-handed, or zero
/// otherwise
///
/// @see libinput_device_config_left_handed_set
/// @see libinput_device_config_left_handed_get
/// @see libinput_device_config_left_handed_get_default 
 
 pub fn libinput_device_config_left_handed_is_available ( device : * mut libinput_device , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup config
///
/// Set the left-handed configuration of the device.
///
/// The exact behavior is device-dependent. On a mouse and most pointing
/// devices, left and right buttons are swapped but the middle button is
/// unmodified. On a touchpad, physical buttons (if present) are swapped. On a
/// clickpad, the top and bottom software-emulated buttons are swapped where
/// present, the main area of the touchpad remains a left button. Tapping and
/// clickfinger behavior is not affected by this setting.
///
/// Changing the left-handed configuration of a device may not take effect
/// until all buttons have been logically released.
///
/// @param device The device to configure
/// @param left_handed Zero to disable, non-zero to enable left-handed mode
/// @return A configuration status code
///
/// @see libinput_device_config_left_handed_is_available
/// @see libinput_device_config_left_handed_get
/// @see libinput_device_config_left_handed_get_default 
 
 pub fn libinput_device_config_left_handed_set ( device : * mut libinput_device , left_handed : ::libc :: c_int , ) -> libinput_config_status ; 
} extern "C" {
 
 /// @ingroup config
///
/// Get the current left-handed configuration of the device.
///
/// @param device The device to configure
/// @return Zero if the device is in right-handed mode, non-zero if the
/// device is in left-handed mode
///
/// @see libinput_device_config_left_handed_is_available
/// @see libinput_device_config_left_handed_set
/// @see libinput_device_config_left_handed_get_default 
 
 pub fn libinput_device_config_left_handed_get ( device : * mut libinput_device , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup config
///
/// Get the default left-handed configuration of the device.
///
/// @param device The device to configure
/// @return Zero if the device is in right-handed mode by default, or non-zero
/// if the device is in left-handed mode by default
///
/// @see libinput_device_config_left_handed_is_available
/// @see libinput_device_config_left_handed_set
/// @see libinput_device_config_left_handed_get 
 
 pub fn libinput_device_config_left_handed_get_default ( device : * mut libinput_device , ) -> ::libc :: c_int ; 
} pub const libinput_config_click_method_LIBINPUT_CONFIG_CLICK_METHOD_NONE : libinput_config_click_method = 0 ; pub const libinput_config_click_method_LIBINPUT_CONFIG_CLICK_METHOD_BUTTON_AREAS : libinput_config_click_method = 1 ; pub const libinput_config_click_method_LIBINPUT_CONFIG_CLICK_METHOD_CLICKFINGER : libinput_config_click_method = 2 ; pub type libinput_config_click_method = ::libc :: c_uint ; extern "C" {
 
 /// @ingroup config
///
/// Check which button click methods a device supports. The button click
/// method defines when to generate software-emulated buttons, usually on a
/// device that does not have a specific physical button available.
///
/// @param device The device to configure
///
/// @return A bitmask of possible methods.
///
/// @see libinput_device_config_click_get_methods
/// @see libinput_device_config_click_set_method
/// @see libinput_device_config_click_get_method 
 
 pub fn libinput_device_config_click_get_methods ( device : * mut libinput_device , ) -> u32 ; 
} extern "C" {
 
 /// @ingroup config
///
/// Set the button click method for this device. The button click
/// method defines when to generate software-emulated buttons, usually on a
/// device that does not have a specific physical button available.
///
/// @note The selected click method may not take effect immediately. The
/// device may require changing to a neutral state first before activating
/// the new method.
///
/// @param device The device to configure
/// @param method The button click method
///
/// @return A config status code
///
/// @see libinput_device_config_click_get_methods
/// @see libinput_device_config_click_get_method
/// @see libinput_device_config_click_get_default_method 
 
 pub fn libinput_device_config_click_set_method ( device : * mut libinput_device , method : libinput_config_click_method , ) -> libinput_config_status ; 
} extern "C" {
 
 /// @ingroup config
///
/// Get the button click method for this device. The button click
/// method defines when to generate software-emulated buttons, usually on a
/// device that does not have a specific physical button available.
///
/// @param device The device to configure
///
/// @return The current button click method for this device
///
/// @see libinput_device_config_click_get_methods
/// @see libinput_device_config_click_set_method
/// @see libinput_device_config_click_get_default_method 
 
 pub fn libinput_device_config_click_get_method ( device : * mut libinput_device , ) -> libinput_config_click_method ; 
} extern "C" {
 
 /// @ingroup config
///
/// Get the default button click method for this device. The button click
/// method defines when to generate software-emulated buttons, usually on a
/// device that does not have a specific physical button available.
///
/// @param device The device to configure
///
/// @return The default button click method for this device
///
/// @see libinput_device_config_click_get_methods
/// @see libinput_device_config_click_set_method
/// @see libinput_device_config_click_get_method 
 
 pub fn libinput_device_config_click_get_default_method ( device : * mut libinput_device , ) -> libinput_config_click_method ; 
} pub const libinput_config_middle_emulation_state_LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED : libinput_config_middle_emulation_state = 0 ; pub const libinput_config_middle_emulation_state_LIBINPUT_CONFIG_MIDDLE_EMULATION_ENABLED : libinput_config_middle_emulation_state = 1 ; pub type libinput_config_middle_emulation_state = ::libc :: c_uint ; extern "C" {
 
 /// @ingroup config
///
/// Check if middle mouse button emulation configuration is available on this
/// device. See @ref middle_button_emulation for details.
///
/// @note Some devices provide middle mouse button emulation but do not allow
/// enabling/disabling that emulation. These devices return zero in
/// libinput_device_config_middle_emulation_is_available().
///
/// @param device The device to query
///
/// @return Non-zero if middle mouse button emulation is available and can be
/// configured, zero otherwise.
///
/// @see libinput_device_config_middle_emulation_set_enabled
/// @see libinput_device_config_middle_emulation_get_enabled
/// @see libinput_device_config_middle_emulation_get_default_enabled 
 
 pub fn libinput_device_config_middle_emulation_is_available ( device : * mut libinput_device , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup config
///
/// Enable or disable middle button emulation on this device. When enabled, a
/// simultaneous press of the left and right button generates a middle mouse
/// button event. Releasing the buttons generates a middle mouse button
/// release, the left and right button events are discarded otherwise.
///
/// See @ref middle_button_emulation for details.
///
/// @param device The device to configure
/// @param enable @ref LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED to
/// disable, @ref LIBINPUT_CONFIG_MIDDLE_EMULATION_ENABLED To enable
/// middle button emulation.
///
/// @return A config status code. Disabling middle button emulation on a
/// device that does not support middle button emulation always succeeds.
///
/// @see libinput_device_config_middle_emulation_is_available
/// @see libinput_device_config_middle_emulation_get_enabled
/// @see libinput_device_config_middle_emulation_get_default_enabled 
 
 pub fn libinput_device_config_middle_emulation_set_enabled ( device : * mut libinput_device , enable : libinput_config_middle_emulation_state , ) -> libinput_config_status ; 
} extern "C" {
 
 /// @ingroup config
///
/// Check if configurable middle button emulation is enabled on this device.
/// See @ref middle_button_emulation for details.
///
/// If the device does not have configurable middle button emulation, this
/// function returns @ref LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED.
///
/// @note Some devices provide middle mouse button emulation but do not allow
/// enabling/disabling that emulation. These devices always return @ref
/// LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED.
///
/// @param device The device to configure
/// @return @ref LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED if disabled
/// or not available/configurable, @ref
/// LIBINPUT_CONFIG_MIDDLE_EMULATION_ENABLED If enabled.
///
/// @see libinput_device_config_middle_emulation_is_available
/// @see libinput_device_config_middle_emulation_set_enabled
/// @see libinput_device_config_middle_emulation_get_default_enabled 
 
 pub fn libinput_device_config_middle_emulation_get_enabled ( device : * mut libinput_device , ) -> libinput_config_middle_emulation_state ; 
} extern "C" {
 
 /// @ingroup config
///
/// Check if configurable middle button emulation is enabled by default on
/// this device. See @ref middle_button_emulation for details.
///
/// If the device does not have configurable middle button
/// emulation, this function returns @ref
/// LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED.
///
/// @note Some devices provide middle mouse button emulation but do not allow
/// enabling/disabling that emulation. These devices always return @ref
/// LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED.
///
/// @param device The device to configure
/// @return @ref LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED If disabled
/// or not available, @ref LIBINPUT_CONFIG_MIDDLE_EMULATION_ENABLED if
/// enabled.
///
/// @see libinput_device_config_middle_emulation_is_available
/// @see libinput_device_config_middle_emulation_set_enabled
/// @see libinput_device_config_middle_emulation_get_enabled 
 
 pub fn libinput_device_config_middle_emulation_get_default_enabled ( device : * mut libinput_device , ) -> libinput_config_middle_emulation_state ; 
} pub const libinput_config_scroll_method_LIBINPUT_CONFIG_SCROLL_NO_SCROLL : libinput_config_scroll_method = 0 ; pub const libinput_config_scroll_method_LIBINPUT_CONFIG_SCROLL_2FG : libinput_config_scroll_method = 1 ; pub const libinput_config_scroll_method_LIBINPUT_CONFIG_SCROLL_EDGE : libinput_config_scroll_method = 2 ; pub const libinput_config_scroll_method_LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN : libinput_config_scroll_method = 4 ; pub type libinput_config_scroll_method = ::libc :: c_uint ; extern "C" {
 
 /// @ingroup config
///
/// Check which scroll methods a device supports. The method defines when to
/// generate scroll axis events instead of pointer motion events.
///
/// @param device The device to configure
///
/// @return A bitmask of possible methods.
///
/// @see libinput_device_config_scroll_set_method
/// @see libinput_device_config_scroll_get_method
/// @see libinput_device_config_scroll_get_default_method
/// @see libinput_device_config_scroll_set_button
/// @see libinput_device_config_scroll_get_button
/// @see libinput_device_config_scroll_get_default_button 
 
 pub fn libinput_device_config_scroll_get_methods ( device : * mut libinput_device , ) -> u32 ; 
} extern "C" {
 
 /// @ingroup config
///
/// Set the scroll method for this device. The method defines when to
/// generate scroll axis events instead of pointer motion events.
///
/// @note Setting @ref LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN enables
/// the scroll method, but scrolling is only activated when the configured
/// button is held down. If no button is set, i.e.
/// libinput_device_config_scroll_get_button() returns 0, scrolling
/// cannot activate.
///
/// @param device The device to configure
/// @param method The scroll method for this device.
///
/// @return A config status code.
///
/// @see libinput_device_config_scroll_get_methods
/// @see libinput_device_config_scroll_get_method
/// @see libinput_device_config_scroll_get_default_method
/// @see libinput_device_config_scroll_set_button
/// @see libinput_device_config_scroll_get_button
/// @see libinput_device_config_scroll_get_default_button 
 
 pub fn libinput_device_config_scroll_set_method ( device : * mut libinput_device , method : libinput_config_scroll_method , ) -> libinput_config_status ; 
} extern "C" {
 
 /// @ingroup config
///
/// Get the scroll method for this device. The method defines when to
/// generate scroll axis events instead of pointer motion events.
///
/// @param device The device to configure
/// @return The current scroll method for this device.
///
/// @see libinput_device_config_scroll_get_methods
/// @see libinput_device_config_scroll_set_method
/// @see libinput_device_config_scroll_get_default_method
/// @see libinput_device_config_scroll_set_button
/// @see libinput_device_config_scroll_get_button
/// @see libinput_device_config_scroll_get_default_button 
 
 pub fn libinput_device_config_scroll_get_method ( device : * mut libinput_device , ) -> libinput_config_scroll_method ; 
} extern "C" {
 
 /// @ingroup config
///
/// Get the default scroll method for this device. The method defines when to
/// generate scroll axis events instead of pointer motion events.
///
/// @param device The device to configure
/// @return The default scroll method for this device.
///
/// @see libinput_device_config_scroll_get_methods
/// @see libinput_device_config_scroll_set_method
/// @see libinput_device_config_scroll_get_method
/// @see libinput_device_config_scroll_set_button
/// @see libinput_device_config_scroll_get_button
/// @see libinput_device_config_scroll_get_default_button 
 
 pub fn libinput_device_config_scroll_get_default_method ( device : * mut libinput_device , ) -> libinput_config_scroll_method ; 
} extern "C" {
 
 /// @ingroup config
///
/// Set the button for the @ref LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN method
/// for this device.
///
/// When the current scroll method is set to @ref
/// LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN, no button press/release events
/// will be send for the configured button.
///
/// When the configured button is pressed, any motion events along a
/// scroll-capable axis are turned into scroll axis events.
///
/// @note Setting the button does not change the scroll method. To change the
/// scroll method call libinput_device_config_scroll_set_method().
///
/// If the button is 0, button scrolling is effectively disabled.
///
/// @param device The device to configure
/// @param button The button which when pressed switches to sending scroll events
///
/// @return A config status code
/// @retval LIBINPUT_CONFIG_STATUS_SUCCESS On success
/// @retval LIBINPUT_CONFIG_STATUS_UNSUPPORTED If @ref
/// LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN is not supported
/// @retval LIBINPUT_CONFIG_STATUS_INVALID The given button does not
/// exist on this device
///
/// @see libinput_device_config_scroll_get_methods
/// @see libinput_device_config_scroll_set_method
/// @see libinput_device_config_scroll_get_method
/// @see libinput_device_config_scroll_get_default_method
/// @see libinput_device_config_scroll_get_button
/// @see libinput_device_config_scroll_get_default_button 
 
 pub fn libinput_device_config_scroll_set_button ( device : * mut libinput_device , button : u32 , ) -> libinput_config_status ; 
} extern "C" {
 
 /// @ingroup config
///
/// Get the button for the @ref LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN method
/// for this device.
///
/// If @ref LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN scroll method is not
/// supported, or no button is set, this function returns 0.
///
/// @note The return value is independent of the currently selected
/// scroll-method. For button scrolling to activate, a device must have the
/// @ref LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN method enabled, and a non-zero
/// button set as scroll button.
///
/// @param device The device to configure
/// @return The button which when pressed switches to sending scroll events
///
/// @see libinput_device_config_scroll_get_methods
/// @see libinput_device_config_scroll_set_method
/// @see libinput_device_config_scroll_get_method
/// @see libinput_device_config_scroll_get_default_method
/// @see libinput_device_config_scroll_set_button
/// @see libinput_device_config_scroll_get_default_button 
 
 pub fn libinput_device_config_scroll_get_button ( device : * mut libinput_device , ) -> u32 ; 
} extern "C" {
 
 /// @ingroup config
///
/// Get the default button for the @ref LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN
/// method for this device.
///
/// If @ref LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN scroll method is not supported,
/// or no default button is set, this function returns 0.
///
/// @param device The device to configure
/// @return The default button for the @ref
/// LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN method
///
/// @see libinput_device_config_scroll_get_methods
/// @see libinput_device_config_scroll_set_method
/// @see libinput_device_config_scroll_get_method
/// @see libinput_device_config_scroll_get_default_method
/// @see libinput_device_config_scroll_set_button
/// @see libinput_device_config_scroll_get_button 
 
 pub fn libinput_device_config_scroll_get_default_button ( device : * mut libinput_device , ) -> u32 ; 
} pub const libinput_config_dwt_state_LIBINPUT_CONFIG_DWT_DISABLED : libinput_config_dwt_state = 0 ; pub const libinput_config_dwt_state_LIBINPUT_CONFIG_DWT_ENABLED : libinput_config_dwt_state = 1 ; pub type libinput_config_dwt_state = ::libc :: c_uint ; extern "C" {
 
 /// @ingroup config
///
/// Check if this device supports configurable disable-while-typing feature.
/// This feature is usually available on built-in touchpads and disables the
/// touchpad while typing. See @ref disable-while-typing for details.
///
/// @param device The device to configure
/// @return 0 if this device does not support disable-while-typing, or 1
/// otherwise.
///
/// @see libinput_device_config_dwt_set_enabled
/// @see libinput_device_config_dwt_get_enabled
/// @see libinput_device_config_dwt_get_default_enabled 
 
 pub fn libinput_device_config_dwt_is_available ( device : * mut libinput_device , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup config
///
/// Enable or disable the disable-while-typing feature. When enabled, the
/// device will be disabled while typing and for a short period after. See
/// @ref disable-while-typing for details.
///
/// @note Enabling or disabling disable-while-typing may not take effect
/// immediately.
///
/// @param device The device to configure
/// @param enable @ref LIBINPUT_CONFIG_DWT_DISABLED to disable
/// disable-while-typing, @ref LIBINPUT_CONFIG_DWT_ENABLED to enable
///
/// @return A config status code. Disabling disable-while-typing on a
/// device that does not support the feature always succeeds.
///
/// @see libinput_device_config_dwt_is_available
/// @see libinput_device_config_dwt_get_enabled
/// @see libinput_device_config_dwt_get_default_enabled 
 
 pub fn libinput_device_config_dwt_set_enabled ( device : * mut libinput_device , enable : libinput_config_dwt_state , ) -> libinput_config_status ; 
} extern "C" {
 
 /// @ingroup config
///
/// Check if the disable-while typing feature is currently enabled on this
/// device. If the device does not support disable-while-typing, this
/// function returns @ref LIBINPUT_CONFIG_DWT_DISABLED.
///
/// @param device The device to configure
/// @return @ref LIBINPUT_CONFIG_DWT_DISABLED if disabled, @ref
/// LIBINPUT_CONFIG_DWT_ENABLED if enabled.
///
/// @see libinput_device_config_dwt_is_available
/// @see libinput_device_config_dwt_set_enabled
/// @see libinput_device_config_dwt_get_default_enabled 
 
 pub fn libinput_device_config_dwt_get_enabled ( device : * mut libinput_device , ) -> libinput_config_dwt_state ; 
} extern "C" {
 
 /// @ingroup config
///
/// Check if the disable-while typing feature is enabled on this device by
/// default. If the device does not support disable-while-typing, this
/// function returns @ref LIBINPUT_CONFIG_DWT_DISABLED.
///
/// @param device The device to configure
/// @return @ref LIBINPUT_CONFIG_DWT_DISABLED if disabled, @ref
/// LIBINPUT_CONFIG_DWT_ENABLED if enabled.
///
/// @see libinput_device_config_dwt_is_available
/// @see libinput_device_config_dwt_set_enabled
/// @see libinput_device_config_dwt_get_enabled 
 
 pub fn libinput_device_config_dwt_get_default_enabled ( device : * mut libinput_device , ) -> libinput_config_dwt_state ; 
} extern "C" {
 
 /// @ingroup config
///
/// Check whether a device can have a custom rotation applied.
///
/// @param device The device to configure
/// @return Non-zero if a device can be rotated, zero otherwise.
///
/// @see libinput_device_config_rotation_set_angle
/// @see libinput_device_config_rotation_get_angle
/// @see libinput_device_config_rotation_get_default_angle 
 
 pub fn libinput_device_config_rotation_is_available ( device : * mut libinput_device , ) -> ::libc :: c_int ; 
} extern "C" {
 
 /// @ingroup config
///
/// Set the rotation of a device in degrees clockwise off the logical neutral
/// position. Any subsequent motion events are adjusted according to the
/// given angle.
///
/// The angle has to be in the range of [0, 360[ degrees, otherwise this
/// function returns LIBINPUT_CONFIG_STATUS_INVALID. If the angle is a
/// multiple of 360 or negative, the caller must ensure the correct ranging
/// before calling this function.
///
/// libinput guarantees that this function accepts multiples of 90 degrees.
/// If a value is within the [0, 360[ range but not a multiple of 90 degrees,
/// this function may return LIBINPUT_CONFIG_STATUS_INVALID if the underlying
/// device or implementation does not support finer-grained rotation angles.
///
/// The rotation angle is applied to all motion events emitted by the device.
/// Thus, rotating the device also changes the angle required or presented by
/// scrolling, gestures, etc.
///
/// @param device The device to configure
/// @param degrees_cw The angle in degrees clockwise
/// @return A config status code. Setting a rotation of 0 degrees on a
/// device that does not support rotation always succeeds.
///
/// @see libinput_device_config_rotation_is_available
/// @see libinput_device_config_rotation_get_angle
/// @see libinput_device_config_rotation_get_default_angle 
 
 pub fn libinput_device_config_rotation_set_angle ( device : * mut libinput_device , degrees_cw : ::libc :: c_uint , ) -> libinput_config_status ; 
} extern "C" {
 
 /// @ingroup config
///
/// Get the current rotation of a device in degrees clockwise off the logical
/// neutral position. If this device does not support rotation, the return
/// value is always 0.
///
/// @param device The device to configure
/// @return The angle in degrees clockwise
///
/// @see libinput_device_config_rotation_is_available
/// @see libinput_device_config_rotation_set_angle
/// @see libinput_device_config_rotation_get_default_angle 
 
 pub fn libinput_device_config_rotation_get_angle ( device : * mut libinput_device , ) -> ::libc :: c_uint ; 
} extern "C" {
 
 /// @ingroup config
///
/// Get the default rotation of a device in degrees clockwise off the logical
/// neutral position. If this device does not support rotation, the return
/// value is always 0.
///
/// @param device The device to configure
/// @return The default angle in degrees clockwise
///
/// @see libinput_device_config_rotation_is_available
/// @see libinput_device_config_rotation_set_angle
/// @see libinput_device_config_rotation_get_angle 
 
 pub fn libinput_device_config_rotation_get_default_angle ( device : * mut libinput_device , ) -> ::libc :: c_uint ; 
} pub type __builtin_va_list = [ __va_list_tag ; 1usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __va_list_tag { pub gp_offset : ::libc :: c_uint , pub fp_offset : ::libc :: c_uint , pub overflow_arg_area : * mut ::libc :: c_void , pub reg_save_area : * mut ::libc :: c_void , } # [ test ] fn bindgen_test_layout___va_list_tag ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __va_list_tag > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( __va_list_tag ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __va_list_tag > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __va_list_tag ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( gp_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( fp_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( overflow_arg_area ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( reg_save_area ) ) ) ; }